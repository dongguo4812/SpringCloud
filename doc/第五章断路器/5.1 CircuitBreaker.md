为什么不再使用Hystrix

Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。

![image-20240330104234255](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403311709020.png)



Hystrix目前也进入维护模式，并且官方推荐使用resilience4j

# 分布式系统面临的问题

复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免地失败。

![image-20240330111528169](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403311709027.png)

## 服务雪崩

多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”.

 

对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。

所以，通常当你发现一个模块下的某个实例失败后，这时候这个模块依然还会接收流量，然后这个有问题的模块还调用了其他的模块，这样就会发生级联故障，或者叫雪崩。

### 2023年影响极大的真实生产故障

语雀（2023.10.23）

![image-20240330111621620](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403311709215.png)



阿里系大部分产品（2023.11.12）

![image-20240330111656092](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403311709825.png)

阿里云产品控制台

![image-20240330111845376](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403311709501.png)

## 如何搞定服务雪崩问题，避免整个系统大面积故障

“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的、可处理的备选响应(FallBack)，而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。

服务熔断：有问题的节点，将后续的请求快速失败

服务降级：不让客户端等待，立刻返回默认兜底数据，如服务器忙，请稍后再试。

服务限流：秒杀高并发等场景，在一定时间段内限制对特定资源或服务的请求速率

服务预热：确保服务在上线或重启后能够迅速达到稳定的运行状态

服务监控：监控微服务的性能、调用关系、异常情况等，及时发现并解决问题

# CircuitBreaker简介

CircuitBreaker的目的是保护分布式系统免受故障和异常，提高系统的可用性和健壮性。

当一个组件或服务出现故障时，CircuitBreaker会迅速切换到开放OPEN状态(保险丝跳闸断电)，阻止请求发送到该组件或服务从而避免更多的请求发送到该组件或服务。这可以减少对该组件或服务的负载，防止该组件或服务进一步崩溃，并使整个系统能够继续正常运行。同时，CircuitBreaker还可以提高系统的可用性和健壮性，因为它可以在分布式系统的各个组件之间自动切换，从而避免单点故障的问题。

Circuit Breaker只是一套规范和接口，落地实现者是Resilience4J、Spring Retry.

![image-20240330132648046](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403311709981.png)

## Resilience4J

![image-20240330132924882](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403311709038.png)

非官方中文文档：https://github.com/lmhmhl/Resilience4j-Guides-Chinese/blob/main/index.md 

### 相关核心模块

![image-20240330133057083](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403311709108.png)

# 熔断（CircuitBreaker）

## 断路器的三大状态

断路器通过有限状态机实现，有三个普通状态：关闭、开启、半开，还有两个特殊状态：禁用、强制开启。

断路器使用滑动窗口来存储和统计调用的结果。你可以选择基于调用数量的滑动窗口或者基于时间的滑动窗口。基于访问数量的滑动窗口统计了最近N次调用的返回结果。居于时间的滑动窗口统计了最近N秒的调用返回结果。



![image-20240330133644452](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403311709374.png)

## 断路器核心配置参数

| 配置属性                                      | 默认值                                                       | 描述                                                         |
| --------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| failureRateThreshold                          | 50                                                           | 以百分比配置失败率阈值。当失败率等于或大于阈值时，断路器状态并关闭变为开启，并进行服务降级。 |
| slowCallRateThreshold                         | 100                                                          | 以百分比的方式配置，断路器把调用时间大于`slowCallDurationThreshold`的调用视为满调用，当慢调用比例大于等于阈值时，断路器开启，并进行服务降级。 |
| slowCallDurationThreshold                     | 60000 [ms]                                                   | 配置调用时间的阈值，高于该阈值的呼叫视为慢调用，并增加慢调用比例。 |
| permittedNumberOfCallsInHalfOpenState         | 10                                                           | 断路器在半开状态下允许通过的调用次数。                       |
| maxWaitDurationInHalfOpenState                | 0                                                            | 断路器在半开状态下的最长等待时间，超过该配置值的话，断路器会从半开状态恢复为开启状态。配置是0时表示断路器会一直处于半开状态，直到所有允许通过的访问结束。 |
| slidingWindowType                             | COUNT_BASED                                                  | 配置滑动窗口的类型，当断路器关闭时，将调用的结果记录在滑动窗口中。滑动窗口的类型可以是count-based或time-based。如果滑动窗口类型是COUNT_BASED，将会统计记录最近`slidingWindowSize`次调用的结果。如果是TIME_BASED，将会统计记录最近`slidingWindowSize`秒的调用结果。 |
| slidingWindowSize                             | 100                                                          | 配置滑动窗口的大小。                                         |
| minimumNumberOfCalls                          | 100                                                          | 断路器计算失败率或慢调用率之前所需的最小调用数（每个滑动窗口周期）。例如，如果minimumNumberOfCalls为10，则必须至少记录10个调用，然后才能计算失败率。如果只记录了9次调用，即使所有9次调用都失败，断路器也不会开启。 |
| waitDurationInOpenState                       | 60000 [ms]                                                   | 断路器从开启过渡到半开应等待的时间。                         |
| automaticTransition FromOpenToHalfOpenEnabled | false                                                        | 如果设置为true，则意味着断路器将自动从开启状态过渡到半开状态，并且不需要调用来触发转换。创建一个线程来监视断路器的所有实例，以便在WaitDurationInOpenstate之后将它们转换为半开状态。但是，如果设置为false，则只有在发出调用时才会转换到半开，即使在waitDurationInOpenState之后也是如此。这里的优点是没有线程监视所有断路器的状态。 |
| recordExceptions                              | empty                                                        | 记录为失败并因此增加失败率的异常列表。 除非通过ignoreExceptions显式忽略，否则与列表中某个匹配或继承的异常都将被视为失败。 如果指定异常列表，则所有其他异常均视为成功，除非它们被ignoreExceptions显式忽略。 |
| ignoreExceptions                              | empty                                                        | 被忽略且既不算失败也不算成功的异常列表。 任何与列表之一匹配或继承的异常都不会被视为失败或成功，即使异常是recordExceptions的一部分。 |
| recordException                               | throwable -> true· By default all exceptions are recored as failures. | 一个自定义断言，用于评估异常是否应记录为失败。 如果异常应计为失败，则断言必须返回true。如果出断言返回false，应算作成功，除非ignoreExceptions显式忽略异常。 |
| ignoreException                               | throwable -> false By default no exception is ignored.       | 自定义断言来判断一个异常是否应该被忽略，如果应忽略异常，则谓词必须返回true。 如果异常应算作失败，则断言必须返回false。 |



默认配置或更多配置查看io.github.resilience4j.circuitbreaker.CircuitBreakerConfig

## 失败率和慢调用率阈值

当失败率大于或等于配置的阈值时，断路器的状态将从关闭变为开启，例如，当超过50%的调用失败时，断路器开启。

当慢调用的百分比大于等于配置的阈值时，断路器的状态将从关闭变为开启，例如，当超过50%的调用响应时间超过10秒时，断路器开启，这有助于在外部系统实际上没有响应之前减少它的负载。

只有在记录了最小调用次数的情况下，才能计算失败率和慢调用率。例如，如果所需调用的最小数目为10，则必须至少记录10个调用，然后才能计算失败率。如果只记录了9个调用，即使所有9个调用都失败，断路器也不会开启。

## 熔断流程

服务熔断、降级举例说明：

1、当超过50%的调用响应时间超过10秒时CircuitBreaker将进入开启OPEN状态(保险丝跳闸断电)拒绝所有请求。

2、等待5秒后，CircuitBreaker 将自动从开启OPEN状态过渡到半开HALF_OPEN状态，允许一些请求通过以测试服务是否恢复正常。

3、如果还是异常CircuitBreaker 将重新进入开启OPEN状态；如果请求正常将进入关闭CLOSE闭合状态恢复正常处理请求。

![image-20240330135254686](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403311709724.png)

## 计数的滑动窗口

基于访问数量的滑动窗口是通过一个有N个元素的循环数组实现。

如果滑动窗口的大小等于10，那么循环数组总是有10个统计值。滑动窗口增量更新总的统计值，随着新的调用结果被记录在环形数组中，总的统计值也随之进行更新。当环形数组满了，时间最久的元素将被驱逐，将从总的统计值中减去该元素的统计值，并该元素所在的桶进行重置。

检索快照（总的统计值）的时间复杂度为O(1)，因为快照已经预先统计好了，并且和滑动窗口大小无关。

关于此方法实现的空间需求（内存消耗）为O(n)。

![image-20240330140625013](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403311709739.png)

### 修改cloud-provider-payment8001

新建PayCircuitController

```java
import cn.hutool.core.date.DateUtil;
import com.dongguo.cloud.resp.Result;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

import java.util.concurrent.TimeUnit;

/**
 * Resilience4j CircuitBreaker 的例子
 */
@RestController
public class PayCircuitController {
    @GetMapping(value = "/pay/circuit/{id}")
    public Result myCircuit(@PathVariable("id") Integer id) {
        if (id < 0) throw new RuntimeException("----circuit id 不能负数");
        if (id >= 9999) {
            try {
                TimeUnit.SECONDS.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        return Result.success("Hello, circuit! inputId:  " + id + " \t " + DateUtil.now());
    }
}
```

### 修改cloud-api-common

PayFeignApi接口添加CircuitBreaker的feign接口

```java
/**
 * Resilience4j CircuitBreaker 的例子
 */
@GetMapping(value = "/pay/circuit/{id}")
Result myCircuit(@PathVariable("id") Integer id);
```

重新install一个公共模块

### 修改cloud-consumer-feign-order80

1.pom

```xml
        <!--resilience4j-circuitbreaker-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-circuitbreaker-resilience4j</artifactId>
        </dependency>
```

由于断路保护等需要AOP实现，所以必须导入AOP包，但是在OpenFeign依赖中已经包含Aop的依赖，所以这里就不再重复引入

![image-20240330155905487](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403311709397.png)

2.yml

```yaml
spring:
  cloud:
    openfeign:
      client:
        config:
          default:               #default所有feign接口有效
            connectTimeout: 60000 #默认值 60000毫秒
            readTimeout: 60000   
     # 开启circuitbreaker和分组激活 
      circuitbreaker:
        enabled: true
        group:
          enabled: true #没开分组永远不用分组的配置。精确优先、分组次之(开了分组)、默认最后
# Resilience4j CircuitBreaker 按照次数：COUNT_BASED 的例子
#  6次访问中当执行方法的失败率达到50%时CircuitBreaker将进入开启OPEN状态(保险丝跳闸断电)拒绝所有请求。
#  等待5秒后，CircuitBreaker 将自动从开启OPEN状态过渡到半开HALF_OPEN状态，允许一些请求通过以测试服务是否恢复正常。
#  如还是异常CircuitBreaker 将重新进入开启OPEN状态；如正常将进入关闭CLOSE闭合状态恢复正常处理请求。
resilience4j:
  circuitbreaker:
    configs:
      default:
        failureRateThreshold: 50 #设置50%的调用失败时打开断路器，超过失败请求百分⽐CircuitBreaker变为OPEN状态。
        slidingWindowType: COUNT_BASED # 滑动窗口的类型 计数的滑动窗口
        slidingWindowSize: 10 #滑动窗⼝的⼤⼩配置COUNT_BASED表示10个请求，若slidingWindowType配置TIME_BASED表示10秒
        minimumNumberOfCalls: 10 #断路器计算失败率或慢调用率之前所需的最小样本(每个滑动窗口周期)。如果minimumNumberOfCalls为10，则必须最少记录10个样本，然后才能计算失败率。如果只记录了9次调用，即使所有9次调用都失败，断路器也不会开启。
        automaticTransitionFromOpenToHalfOpenEnabled: true # 是否启用自动从开启状态过渡到半开状态，默认值为true。如果启用，CircuitBreaker将自动从开启状态过渡到半开状态，并允许一些请求通过以测试服务是否恢复正常
        waitDurationInOpenState: 5s #从OPEN到HALF_OPEN状态需要等待的时间
        permittedNumberOfCallsInHalfOpenState: 2 #半开状态允许的最大请求数，默认值为10。在半开状态下，CircuitBreaker将允许最多permittedNumberOfCallsInHalfOpenState个请求通过，如果其中有任何一个请求失败，CircuitBreaker将重新进入开启状态。
        recordExceptions:
          - java.lang.Exception
    instances:
      cloud-payment-service:
        baseConfig: default                 
```

3.新建OrderCircuitController

实现服务熔断、降级

```java
import com.dongguo.cloud.feign.PayFeignApi;
import com.dongguo.cloud.resp.Result;
import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.annotation.Resource;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

@RestController
@Tag(name = "订单断路器模块", description = "订单控制器接口")
public class OrderCircuitController {
    @Resource
    private PayFeignApi payFeignApi;

    @GetMapping(value = "/feign/pay/circuit/{id}")
    @CircuitBreaker(name = "cloud-payment-service", fallbackMethod = "myCircuitFallback")
    @Operation(summary = "测试断路器功能")
    public Result myCircuitBreaker(@PathVariable("id") Integer id) {
        return payFeignApi.myCircuit(id);
    }

    /**
     * myCircuitFallback就是服务降级后的兜底处理方法
     * @param id
     * @param t
     * @return
     */
    public String myCircuitFallback(Integer id, Throwable t) {
        // 这里是容错处理逻辑，返回备用结果
        return "myCircuitFallback，系统繁忙，请稍后再试!";
    }
}
```

### 测试

1.正常访问

http://127.0.0.1/feign/pay/circuit/1

![image-20240330144336171](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403311709427.png)

```shell
2024-03-30T14:42:44.713+08:00 DEBUG 12312 --- [cloud-consumer-openfeign-order] [pool-5-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myCircuit] ---> GET http://cloud-payment-service/pay/circuit/1 HTTP/1.1
2024-03-30T14:42:44.713+08:00 DEBUG 12312 --- [cloud-consumer-openfeign-order] [pool-5-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myCircuit] ---> END HTTP (0-byte body)
2024-03-30T14:42:44.817+08:00 DEBUG 12312 --- [cloud-consumer-openfeign-order] [pool-5-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myCircuit] <--- HTTP/1.1 200  (104ms)
2024-03-30T14:42:44.818+08:00 DEBUG 12312 --- [cloud-consumer-openfeign-order] [pool-5-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myCircuit] connection: keep-alive
2024-03-30T14:42:44.818+08:00 DEBUG 12312 --- [cloud-consumer-openfeign-order] [pool-5-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myCircuit] content-type: application/json
2024-03-30T14:42:44.818+08:00 DEBUG 12312 --- [cloud-consumer-openfeign-order] [pool-5-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myCircuit] date: Sat, 30 Mar 2024 06:42:44 GMT
2024-03-30T14:42:44.818+08:00 DEBUG 12312 --- [cloud-consumer-openfeign-order] [pool-5-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myCircuit] keep-alive: timeout=60
2024-03-30T14:42:44.818+08:00 DEBUG 12312 --- [cloud-consumer-openfeign-order] [pool-5-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myCircuit] transfer-encoding: chunked
2024-03-30T14:42:44.818+08:00 DEBUG 12312 --- [cloud-consumer-openfeign-order] [pool-5-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myCircuit] 
2024-03-30T14:42:44.819+08:00 DEBUG 12312 --- [cloud-consumer-openfeign-order] [pool-5-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myCircuit] {"code":"200","message":"success","data":"Hello, circuit! inputId:  1 \t 2024-03-30 14:42:44","timestamp":1711780964811}
2024-03-30T14:42:44.819+08:00 DEBUG 12312 --- [cloud-consumer-openfeign-order] [pool-5-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myCircuit] <--- END HTTP (120-byte body)
```

2.异常访问

yml中配置了recordExceptions:   - java.lang.Exception，CircuitBreaker会将所有异常进行服务降级

http://127.0.0.1/feign/pay/circuit/-1

![image-20240330152023279](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403311708980.png)

```java
2024-03-30T15:20:39.796+08:00 DEBUG 4656 --- [cloud-consumer-openfeign-order] [ool-5-thread-13] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myCircuit] ---> GET http://cloud-payment-service/pay/circuit/-1 HTTP/1.1
2024-03-30T15:20:39.796+08:00 DEBUG 4656 --- [cloud-consumer-openfeign-order] [ool-5-thread-13] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myCircuit] ---> END HTTP (0-byte body)
2024-03-30T15:20:39.805+08:00 DEBUG 4656 --- [cloud-consumer-openfeign-order] [ool-5-thread-13] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myCircuit] <--- HTTP/1.1 500  (8ms)
2024-03-30T15:20:39.805+08:00 DEBUG 4656 --- [cloud-consumer-openfeign-order] [ool-5-thread-13] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myCircuit] connection: close
2024-03-30T15:20:39.805+08:00 DEBUG 4656 --- [cloud-consumer-openfeign-order] [ool-5-thread-13] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myCircuit] content-type: application/json
2024-03-30T15:20:39.805+08:00 DEBUG 4656 --- [cloud-consumer-openfeign-order] [ool-5-thread-13] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myCircuit] date: Sat, 30 Mar 2024 07:20:39 GMT
2024-03-30T15:20:39.805+08:00 DEBUG 4656 --- [cloud-consumer-openfeign-order] [ool-5-thread-13] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myCircuit] transfer-encoding: chunked
2024-03-30T15:20:39.805+08:00 DEBUG 4656 --- [cloud-consumer-openfeign-order] [ool-5-thread-13] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myCircuit] 
2024-03-30T15:20:39.806+08:00 DEBUG 4656 --- [cloud-consumer-openfeign-order] [ool-5-thread-13] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myCircuit] {"code":"500","message":"----circuit id 不能负数","data":null,"timestamp":1711783239803}
2024-03-30T15:20:39.806+08:00 DEBUG 4656 --- [cloud-consumer-openfeign-order] [ool-5-thread-13] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myCircuit] <--- END HTTP (92-byte body)
```

这是访问异常进行了服务降级，还并未开启熔断，重新访问http://127.0.0.1/feign/pay/circuit/1 依然能够正常请求

3.访问5次http://127.0.0.1/feign/pay/circuit/-1，再去访问http://127.0.0.1/feign/pay/circuit/1 (10次请求超过50%异常)

因为这是基于计数的滑动窗口，所以最好多次访问正常请求，将滑动窗口中之前产生的异常请求驱逐再进行测试

![image-20240330152407225](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403311708613.png)

控制台最后并未显示访问http://127.0.0.1/feign/pay/circuit/1 的请求，因为在一个滑动窗口内超过一半的请求失败，进入熔断，在从开启OPEN状态过渡到半开HALF_OPEN状态的5秒内的请求直接进行降级返回。

```shell
2024-03-30T15:24:56.295+08:00 DEBUG 4656 --- [cloud-consumer-openfeign-order] [ool-5-thread-14] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myCircuit] ---> GET http://cloud-payment-service/pay/circuit/-1 HTTP/1.1
2024-03-30T15:24:56.296+08:00 DEBUG 4656 --- [cloud-consumer-openfeign-order] [ool-5-thread-14] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myCircuit] ---> END HTTP (0-byte body)
2024-03-30T15:24:56.300+08:00 DEBUG 4656 --- [cloud-consumer-openfeign-order] [ool-5-thread-14] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myCircuit] <--- HTTP/1.1 500  (4ms)
2024-03-30T15:24:56.300+08:00 DEBUG 4656 --- [cloud-consumer-openfeign-order] [ool-5-thread-14] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myCircuit] connection: close
2024-03-30T15:24:56.300+08:00 DEBUG 4656 --- [cloud-consumer-openfeign-order] [ool-5-thread-14] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myCircuit] content-type: application/json
2024-03-30T15:24:56.300+08:00 DEBUG 4656 --- [cloud-consumer-openfeign-order] [ool-5-thread-14] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myCircuit] date: Sat, 30 Mar 2024 07:24:55 GMT
2024-03-30T15:24:56.300+08:00 DEBUG 4656 --- [cloud-consumer-openfeign-order] [ool-5-thread-14] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myCircuit] transfer-encoding: chunked
2024-03-30T15:24:56.300+08:00 DEBUG 4656 --- [cloud-consumer-openfeign-order] [ool-5-thread-14] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myCircuit] 
2024-03-30T15:24:56.300+08:00 DEBUG 4656 --- [cloud-consumer-openfeign-order] [ool-5-thread-14] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myCircuit] {"code":"500","message":"----circuit id 不能负数","data":null,"timestamp":1711783496300}
2024-03-30T15:24:56.300+08:00 DEBUG 4656 --- [cloud-consumer-openfeign-order] [ool-5-thread-14] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myCircuit] <--- END HTTP (92-byte body)
```

经过几秒后，再次访问http://127.0.0.1/feign/pay/circuit/1 ，请求成功，熔断已经关闭CLOSE状态

## 时间的滑动窗口

基于时间的滑动窗口是通过有N个桶的环形数组实现。

如果滑动窗口的大小为10秒，这个环形数组总是有10个桶，每个桶统计了在这一秒发生的所有调用的结果（部分统计结果），数组中的第一个桶存储了当前这一秒内的所有调用的结果，其他的桶存储了之前每秒调用的结果。

滑动窗口不会单独存储所有的调用结果，而是对每个桶内的统计结果和总的统计值进行增量的更新，当新的调用结果被记录时，总的统计值会进行增量更新。

检索快照（总的统计值）的时间复杂度为O(1)，因为快照已经预先统计好了，并且和滑动窗口大小无关。

关于此方法实现的空间需求（内存消耗）约等于O(n)。由于每次调用结果（元组）不会被单独存储，只是对N个桶进行单独统计和一次总分的统计。

每个桶在进行部分统计时存在三个整型，为了计算，失败调用数，慢调用数，总调用数。还有一个long类型变量，存储所有调用的响应时间。

![image-20240330140642470](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403311708668.png)

### 修改cloud-consumer-feign-order80

yml

将slidingWindowType: COUNT_BASED修改为slidingWindowType: TIME_BASED

```yaml
# Resilience4j CircuitBreaker 按照时间：TIME_BASED 的例子
resilience4j:
  timelimiter:
    configs:
      default:
        timeout-duration: 10s #神坑的位置，timelimiter 默认限制远程1s，超于1s就超时异常，配置了降级，就走降级逻辑
  circuitbreaker:
    configs:
      default:
        failureRateThreshold: 50 #设置50%的调用失败时打开断路器，超过失败请求百分⽐CircuitBreaker变为OPEN状态。
        slowCallDurationThreshold: 2s #慢调用时间阈值，高于这个阈值的视为慢调用并增加慢调用比例。
        slowCallRateThreshold: 30 #慢调用百分比峰值，断路器把调用时间⼤于slowCallDurationThreshold，视为慢调用，当慢调用比例高于阈值，断路器打开，并开启服务降级
        slidingWindowType: TIME_BASED # 滑动窗口的类型
        slidingWindowSize: 2 #滑动窗口的大小配置，配置TIME_BASED表示2秒
        minimumNumberOfCalls: 2 #断路器计算失败率或慢调用率之前所需的最小样本(每个滑动窗口周期)。
        permittedNumberOfCallsInHalfOpenState: 2 #半开状态允许的最大请求数，默认值为10。
        waitDurationInOpenState: 5s #从OPEN到HALF_OPEN状态需要等待的时间
        recordExceptions:
          - java.lang.Exception
    instances:
      cloud-payment-service:
        baseConfig: default
```

如果不配置timeout-duration: 10s，超时请求只要超过1s就会直接进入服务降级进行返回

### 测试

这次改变一下测试的方式，请求http://127.0.0.1/feign/pay/circuit/9999演示超时导致的请求失败

1.正常访问

http://127.0.0.1/feign/pay/circuit/1

![image-20240330161438957](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403311708148.png)

2.超时访问

http://127.0.0.1/feign/pay/circuit/9999

因为yml中设置了slowCallDurationThreshold: 2s，所以当请求超过两秒后，CircuitBreaker会将这个请求视为慢调用，进行服务降级

发起请求等待10秒后返回服务开启降级保护,请稍后再试!

![image-20240330163349435](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403311708839.png)

3.在10秒内发起2次超时请求http://127.0.0.1/feign/pay/circuit/9999，再请求一次正常请求http://127.0.0.1/feign/pay/circuit/1（只要保证10秒内超过等于2个请求异常或慢调用）进入熔断，在从开启OPEN状态过渡到半开HALF_OPEN状态的5秒内的请求直接进行降级返回。



![image-20240330163722226](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403311708750.png)

# 隔离（BulkHead）

Resilience4j提供了两种隔离的实现方式，可以**限制并发执行的数量**。

- `SemaphoreBulkhead`使用了信号量
- `FixedThreadPoolBulkhead`使用了有界队列和固定大小线程池

`SemaphoreBulkhead`可以在各种线程和I/O模型上正常工作。与Hystrix不同，它不提供基于shadow的thread选项。由客户端来确保正确的线程池大小与隔离配置一致。

可以看到Resilience4j使用到了JUC中的semaphore和ThreadPool

io.github.resilience4j.bulkhead.internal.SemaphoreBulkhead

![image-20240331072231893](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403311708725.png)

io.github.resilience4j.bulkhead.internal.FixedThreadPoolBulkhead

![image-20240331072410399](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403311708589.png)



![image-20240331101422473](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403311708596.png)

## 实现SemaphoreBulkhead(信号量舱壁）

### 信号量舱壁（SemaphoreBulkhead）原理

当信号量有空闲时，进入系统的请求会直接获取信号量并开始业务处理。

当信号量全被占用时，接下来的请求将会进入阻塞状态，SemaphoreBulkhead提供了一个阻塞计时器，如果阻塞状态的请求在阻塞计时内无法获取到信号量则系统会拒绝这些请求。若请求在阻塞计时内获取到了信号量，那将直接获取信号量并执行相应的业务处理。



### cloud-provider-payment8001支付微服务

PayCircuitController添加Resilience4j bulkhead的例子

```java
    @GetMapping(value = "/pay/bulkhead/{id}")
    public Result myBulkhead(@PathVariable("id") Integer id) {
        if (id < 0) throw new RuntimeException("----bulkhead id 不能负数");
        if (id >= 9999) {
            try {
                TimeUnit.SECONDS.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        return Result.success("Hello, bulkhead! inputId:  " + id + " \t " + DateUtil.date());
    }
```

### cloud-api-common

PayFeignApi接口添加舱壁的feign接口

```java
@GetMapping(value = "/pay/bulkhead/{id}")
Result myBulkhead(@PathVariable("id") Integer id);
```

### cloud-consumer-feign-order80

1.pom

`spring-cloud-starter-circuitbreaker-resilience4j` 这个starter是Spring Cloud用于集成Resilience4j熔断器的依赖，主要是获得了熔断器的功能。但服务隔离（Bulkhead）是Resilience4j的另一个核心功能，Spring Cloud的starter并没有将Resilience4j的所有功能都包含进来，而是采取了模块化的方式，允许你根据需要添加不同的功能。如果你想要使用服务隔离（Bulkhead）功能，你需要额外添加`resilience4j-bulkhead`依赖。

```xml
<!--resilience4j-bulkhead-->
<dependency>
    <groupId>io.github.resilience4j</groupId>
    <artifactId>resilience4j-bulkhead</artifactId>
</dependency>
```

2.yml

BulkHead有两个配置属性

![image-20240331094226258](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403311708724.png)

在yml可以有两种方式进行配置

![image-20240331094624781](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403311708523.png)

设置允许并发线程数量2

```yaml

resilience4j:
  timelimiter:
    configs:
      default:
        timeout-duration: 20s  
  ####resilience4j bulkhead      
  bulkhead:
    configs:
      default:
        maxConcurrentCalls: 2 # 隔离允许并发线程执行的最大数量
        maxWaitDuration: 1s # 当达到并发调用数量时，新的线程的阻塞时间，我只愿意等待1秒，过时不候进舱壁兜底fallback
    instances:
      cloud-payment-service:
        baseConfig: default
```



### 业务类

OrderCircuitController

舱壁隔离使用Bulkhead.Type.SEMAPHORE，  SEMAPHORE将调用基于信号量的隔板实现

```java
    /**
     * 舱壁隔离
     * @param id
     * @return
     */
    @GetMapping(value = "/feign/pay/bulkhead/{id}")
    @Bulkhead(name = "cloud-payment-service", fallbackMethod = "myBulkheadFallback", type = Bulkhead.Type.SEMAPHORE)
    public Result myBulkhead(@PathVariable("id") Integer id) {
        return payFeignApi.myBulkhead(id);
    }

    public Result myBulkheadFallback(Throwable t) {
        return Result.fail(RC201.getCode(), "隔板超出最大数量限制" + RC201.getMessage());
    }
```

### 测试

浏览器新打开2个窗口，各点一次，分别点击http://localhost/feign/pay/bulkhead/9999

每个请求调用需要耗时10秒，2个线程瞬间达到配置过的最大并发数2

此时第3个请求正常的请求访问，http://localhost/feign/pay/bulkhead/1

等待1秒后，直接被舱壁限制隔离了，服务降级返回

 ![image-20240331100806587](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403311708843.png)

等其中一个窗口停止了，并发数小于2 了，请求访问http://localhost/feign/pay/bulkhead/1 恢复正常

![image-20240331100952672](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403311708023.png)

## 实现FixedThreadPoolBulkhead(固定线程池舱壁)

FixedThreadPoolBulkhead的功能与SemaphoreBulkhead一样也是**用于限制并发执行的次数**的，但是二者的实现原理存在差别而且表现效果也存在细微的差别。FixedThreadPoolBulkhead使用一个固定线程池和一个等待队列来实现舱壁。

当任务提交到固定线程池舱壁时，如果线程池中有可用的线程，那么任务会立即执行。

如果线程池已满，那么任务会被阻塞，直到有线程可用。

当线程池中存在空闲时，则此时进入系统的请求将直接进入线程池开启新线程或使用空闲线程来处理请求。

当线程池中无空闲时时，接下来的请求将进入等待队列，若等待队列仍然无剩余空间时接下来的请求将直接被拒绝，在队列中的请求等待线程池出现空闲时，将进入线程池进行业务处理。

另外：ThreadPoolBulkhead只对CompletableFuture方法有效，所以我们必创建返回CompletableFuture类型的方法

submit进线程池返回CompletableFuture<T>：

![image-20240331101513094](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403311708485.png)

### 修改cloud-provider-payment8001

新建PayCircuitController

```java
    @GetMapping(value = "/pay/bulkheadPool/{id}")
    public Result myBulkheadPool(@PathVariable("id") Integer id) {
        if (id < 0) throw new RuntimeException("----bulkheadPool id 不能负数");
        if (id >= 9999) {
            try {
                TimeUnit.SECONDS.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        return Result.success("Hello, bulkheadPool! inputId:  " + id + " \t " + DateUtil.date());
    }
```

### 修改cloud-api-common

PayFeignApi接口添加CircuitBreaker的feign接口

```java
    @GetMapping(value = "/pay/bulkheadPool/{id}")
    Result myBulkheadPool(@PathVariable("id") Integer id);
```

重新install一个公共模块

### 修改cloud-consumer-feign-order80

1.yml

![image-20240331102922258](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403311708779.png)



![image-20240331102943672](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403311708831.png)

- **core-thread-pool-size: 1**:
  - 核心线程池大小，即线程池中始终保持的线程数量。即使这些线程是空闲的，它们也不会被销毁。
- **max-thread-pool-size: 1**:
  - 线程池的最大线程数。当任务队列已满，且当前线程数小于这个值时，会创建新的线程来处理任务。
- **queue-capacity: 1**:
  - 任务队列的容量。当线程池中的线程都在忙时，新的任务会被放入这个队列中等待执行。如果队列也满了，那么根据线程池的策略（比如拒绝策略），可能会抛出异常或执行其他操作。

`cloud-payment-service`这个线程池隔离实例将会拥有`core-thread-pool-size`为1，`max-thread-pool-size`为1，和`queue-capacity`为1的线程池设置，线程池最大线程数+队列的容量等于并发的上限。

```yaml
spring:
  cloud:
    openfeign:
      circuitbreaker:
        enabled: true
#      group:
#        enabled: true #没开分组永远不用分组的配置。精确优先、分组次之(开了分组)、默认最后
resilience4j:
  timelimiter:
    configs:
      default:
        timeout-duration: 20s  
  ####resilience4j thread-pool-bulkhead      
  thread-pool-bulkhead:
    configs:
      default:
        core-thread-pool-size: 1
        max-thread-pool-size: 1
        queue-capacity: 1
    instances:
      cloud-payment-service:
        baseConfig: default
```

演示Bulkhead.Type.THREADPOOL时 需要将spring.cloud.openfeign.circuitbreaker.group.enabled设为false 是禁用 Feign 客户端的熔断器功能，即使远程服务出现问题，也不会触发熔断器，而是直接抛出异常/服务降级。



2.业务类

OrderCircuitController

```java
    /**
     * 舱壁隔离,THREADPOOL
     *
     * @param id
     * @return
     */
    @GetMapping(value = "/feign/pay/bulkheadPool/{id}")
    @Bulkhead(name = "cloud-payment-service", fallbackMethod = "myBulkheadPoolFallback", type = Bulkhead.Type.THREADPOOL)
    public CompletableFuture<Result> myBulkheadPool(@PathVariable("id") Integer id) {
        return  CompletableFuture.supplyAsync(() -> payFeignApi.myBulkheadPool(id));
    }

    public  CompletableFuture<Result> myBulkheadPoolFallback(Integer id, Throwable t) {
        return CompletableFuture.supplyAsync(() -> Result.fail(RC201.getCode(),"Bulkhead.Type.THREADPOOL" + RC201.getMessage()));
    }
```

### 测试

浏览器新打开2个窗口，各点一次，分别点击http://localhost/feign/pay/bulkheadPool/10001 、http://localhost/feign/pay/bulkheadPool/10002

每个请求调用需要耗时10秒，2个线程瞬间达到配置过的最大并发数2

此时第3个请求访问，http://localhost/feign/pay/bulkheadPool/1 进行线程隔离，触发服务降级

![image-20240331163725555](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403311708568.png)

前两次请求一共会执行20秒的时间，等待20秒后，再次访问http://localhost/feign/pay/bulkheadPool/1

![image-20240331163811099](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403311708984.png)



这里有一个问题，如果我前两次都是请求http://localhost/feign/pay/bulkheadPool/10001 ，第三次请求http://localhost/feign/pay/bulkheadPool/1，是没有进行线程隔离。

经过测试查看到，当使用`FixedThreadPoolBulkhead`时，如果两个请求具有相同的方法和参数，它们通常会被视为“相同”或“相似”的请求，共享同一个线程池中的线程。

将核心线程，和最大线程数修改为3，那么最大可以处理3+1的并发

```yaml
thread-pool-bulkhead:
  configs:
    default:
      core-thread-pool-size: 3
      max-thread-pool-size: 3
      queue-capacity: 1
  instances:
    cloud-payment-service:
      baseConfig: default
```



```java
@GetMapping(value = "/feign/pay/bulkheadPool/{id}")
@Bulkhead(name = "cloud-payment-service", fallbackMethod = "myBulkheadPoolFallback", type = Bulkhead.Type.THREADPOOL)
public CompletableFuture<Result> myBulkheadPool(@PathVariable("id") Integer id) {

    return CompletableFuture.supplyAsync(() -> {
                System.out.println(Thread.currentThread().getId() + "执行 id  ：" + id);
                return payFeignApi.myBulkheadPool(id);
            }

    );
}
```

当请求3次http://localhost/feign/pay/bulkheadPool/10004，再请求http://localhost/feign/pay/bulkheadPool/1时

按照我们的推理来说应该先执行id为10004的三个请求，id为1的请求会进入阻塞队列，但是打印出的日志显示，先执行一次http://localhost/feign/pay/bulkheadPool/10004，后两次请求进入阻塞，直到执行http://localhost/feign/pay/bulkheadPool/1。后两次的请求http://localhost/feign/pay/bulkheadPool/10004请求是在第一次请求结束后才执行的，而且都是线程id为86执行的。由此的出结论，如果两个请求具有相同的方法和参数，共享同一个线程池中的线程。

```shell
86执行 id  ：10004
2024-03-31T20:51:22.519+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] ---> GET http://cloud-payment-service/pay/bulkheadPool/10004 HTTP/1.1
2024-03-31T20:51:22.519+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] ---> END HTTP (0-byte body)
88执行 id  ：1
2024-03-31T20:51:26.508+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-2] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] ---> GET http://cloud-payment-service/pay/bulkheadPool/1 HTTP/1.1
2024-03-31T20:51:26.508+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-2] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] ---> END HTTP (0-byte body)
2024-03-31T20:51:26.518+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-2] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] <--- HTTP/1.1 200  (9ms)
2024-03-31T20:51:26.518+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-2] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] connection: keep-alive
2024-03-31T20:51:26.518+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-2] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] content-type: application/json
2024-03-31T20:51:26.518+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-2] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] date: Sun, 31 Mar 2024 12:51:26 GMT
2024-03-31T20:51:26.518+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-2] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] keep-alive: timeout=60
2024-03-31T20:51:26.518+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-2] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] transfer-encoding: chunked
2024-03-31T20:51:26.518+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-2] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] 
2024-03-31T20:51:26.519+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-2] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] {"code":"200","message":"success","data":"Hello, bulkheadPool! inputId:  1 \t 2024-03-31 20:51:26","timestamp":1711889486511}
2024-03-31T20:51:26.519+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-2] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] <--- END HTTP (125-byte body)
2024-03-31T20:51:32.619+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] <--- HTTP/1.1 200  (10100ms)
2024-03-31T20:51:32.619+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] connection: keep-alive
2024-03-31T20:51:32.621+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] content-type: application/json
2024-03-31T20:51:32.621+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] date: Sun, 31 Mar 2024 12:51:32 GMT
2024-03-31T20:51:32.621+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] keep-alive: timeout=60
2024-03-31T20:51:32.621+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] transfer-encoding: chunked
2024-03-31T20:51:32.621+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] 
2024-03-31T20:51:32.621+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] {"code":"200","message":"success","data":"Hello, bulkheadPool! inputId:  10004 \t 2024-03-31 20:51:32","timestamp":1711889492618}
2024-03-31T20:51:32.621+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] <--- END HTTP (129-byte body)
86执行 id  ：10004
2024-03-31T20:51:32.629+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] ---> GET http://cloud-payment-service/pay/bulkheadPool/10004 HTTP/1.1
2024-03-31T20:51:32.629+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] ---> END HTTP (0-byte body)
2024-03-31T20:51:42.639+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] <--- HTTP/1.1 200  (10009ms)
2024-03-31T20:51:42.639+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] connection: keep-alive
2024-03-31T20:51:42.639+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] content-type: application/json
2024-03-31T20:51:42.639+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] date: Sun, 31 Mar 2024 12:51:42 GMT
2024-03-31T20:51:42.639+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] keep-alive: timeout=60
2024-03-31T20:51:42.639+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] transfer-encoding: chunked
2024-03-31T20:51:42.639+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] 
2024-03-31T20:51:42.639+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] {"code":"200","message":"success","data":"Hello, bulkheadPool! inputId:  10004 \t 2024-03-31 20:51:42","timestamp":1711889502638}
2024-03-31T20:51:42.639+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] <--- END HTTP (129-byte body)
86执行 id  ：10004
2024-03-31T20:51:42.649+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] ---> GET http://cloud-payment-service/pay/bulkheadPool/10004 HTTP/1.1
2024-03-31T20:51:42.649+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] ---> END HTTP (0-byte body)
2024-03-31T20:51:52.662+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] <--- HTTP/1.1 200  (10012ms)
2024-03-31T20:51:52.662+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] connection: keep-alive
2024-03-31T20:51:52.662+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] content-type: application/json
2024-03-31T20:51:52.662+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] date: Sun, 31 Mar 2024 12:51:52 GMT
2024-03-31T20:51:52.662+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] keep-alive: timeout=60
2024-03-31T20:51:52.662+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] transfer-encoding: chunked
2024-03-31T20:51:52.662+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] 
2024-03-31T20:51:52.662+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] {"code":"200","message":"success","data":"Hello, bulkheadPool! inputId:  10004 \t 2024-03-31 20:51:52","timestamp":1711889512661}
2024-03-31T20:51:52.662+08:00 DEBUG 30920 --- [cloud-consumer-openfeign-order] [pool-2-thread-1] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#myBulkheadPool] <--- END HTTP (129-byte body)
```



# 限流(RateLimiter)

限流 就是限制最大访问流量。系统能提供的最大并发是有限的，同时来的请求又太多， 一旦达到限制速率则可以拒绝服务、排队或等待、降级等处理。

比如商城秒杀业务，瞬时大量请求涌入，服务器忙不过就只好排队限流了，和去景点排队买票和去医院办理业务排队等号道理相同。

## 常见的限流算法
