# 为什么不再使用Ribbon负载均衡客户端

Spring Cloud Ribbon是基于Netflix Ribbon实现的一套*客户端*    负载均衡的工具。

简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法和服务调用。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer（简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。我们很容易使用Ribbon实现自定义的负载均衡算法。

Ribbon也不再更新进入了维护模式  https://github.com/Netflix/ribbon

在很早的官方文章中就给出推荐的替代产品

https://spring.io/blog/2018/12/12/spring-cloud-greenwich-rc1-available-now#spring-cloud-netflix-projects-entering-maintenance-mode

![image-20240329135313902](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403291558436.png)

Ribbon的替代方案：spring-cloud-loadbalancer

# SpringCloud LoadBalancer简介

LoadBalancer在SpringCloud Common模块下https://spring.io/projects/spring-cloud-commons#learn

![image-20240329140435446](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403291558592.png)

## **LB负载均衡(Load Balance)是什么**

简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA（高可用），常见的负载均衡有软件Nginx，LVS，硬件 F5等

## **spring-cloud-starter-loadbalancer组件是什么**

Spring Cloud LoadBalancer是由SpringCloud官方提供的一个开源的、简单易用的**客户端负载均衡器**，它包含在SpringCloud-commons中用它来替换了以前的Ribbon组件。相比较于Ribbon，SpringCloud LoadBalancer不仅能够支持RestTemplate，还支持WebClient（WeClient是Spring Web Flux中提供的功能，可以实现响应式异步请求）



### 负载均衡客户端 

Nginx是服务端负载均衡，客户端所有请求都会交给nginx，然后由nginx实现转发请求，即负载均衡是由服务端实现的。

loadbalancer、Ribbon是客户端负载均衡，在调用微服务接口时候，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术。

# SpringCloud LoadBalancer负载均衡解析

LoadBalancer 在工作时分成两步：

**第一步**，先选择Consul Server从服务端查询并拉取服务列表，知道了它有多个服务(上图3个服务)，这3个实现是完全一样的，

默认轮询调用谁都可以正常执行。类似生活中求医挂号，某个科室今日出诊的全部医生，客户端你自己选一个。

**第二步**，按照指定的负载均衡策略从server取到的服务注册列表中由客户端自己选择一个地址，所以LoadBalancer是一个**客户端的**负载均衡器。

![image-20240329141410271](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403291558446.png)

## WebClient集成LoadBalancer实现负载均衡配置

Spring Cloud LoadBalancer可以与WebClient、RestTemplate配合使用

![image-20240329141658652](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403291558439.png)

在consul服务注册于发现文章中，就将WebClient配置为自动使用负载均衡器客户端，当时只是从注册中心上获取注册信息服务列表后实现了服务远程调用，并没有验证负载均衡功能。![image-20240329142138387](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403291558145.png)

在之前我们已经完成了配置

```java
import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.reactive.function.client.WebClient;

@Configuration
public class WebClientConfig {

    @Bean
    @LoadBalanced
    public WebClient.Builder loadBalancedWebClientBuilder() {
        return WebClient.builder();
    }
}
```



## 支付模块

为了实现负载均衡，我们除了启动8001实例外，再启动相同配置的8002实例

![image-20240329143247850](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403291558875.png)

选中当前项目允许多实例运行、添加VM参数`-Dserver.port=8002`

![image-20240329143226963](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403291558698.png)

点击apply后，修改VM的配置决定启动的是8001还是8002，这样就可以有两个相同的服务实例

![image-20240329143521821](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403291558234.png)



## 订单模块

OrderController实现从consul获取配置的方法，根据返回的port，验证负载均衡的实现。

```java
    @GetMapping(value = "/get/info")
    private Result getInfoByConsul() {
        String url = PAYMENT_SERVICE_URL + "/pay/get/info";
        return webClientBuilder.build().get().uri(url).retrieve().bodyToMono(Result.class).block();
    }
```

## 查看consul已经注册的服务

![image-20240329144435437](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403291558646.png)

## 测试

访问http://localhost/consumer/pay/get/info，端口号根据轮询访问8001/8002实例显示

![image-20240329150626484](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403291558558.png)

![image-20240329150638305](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403291558994.png)

# LoadBalancer负载均衡算法

https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#switching-between-the-load-balancing-algorithms

![image-20240329152726261](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403291558603.png)

Spring Cloud LoadBalancer提供了两种负载均衡算法：

![image-20240329153742194](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403291557876.png)

1. **轮询（Round Robin）**：这是最简单也最常用的负载均衡算法。按照固定的顺序轮流调用每个服务实例，确保每个服务实例都能被均匀地调用到。(默认使用轮询)
2. **随机（Random）**：该算法随机选择一个服务实例进行调用，每次请求都可能选择不同的实例，从而在一定程度上实现了负载均衡。

除了上述两种基础的负载均衡算法，Spring Cloud LoadBalancer还支持自定义负载均衡策略



## 将负载均衡算法切换为随机算法

作为`@LoadBalancerClient`或`@LoadBalancerClients`配置参数传递的类不应该被`@Configuration`注解标记，或者应该处于组件扫描范围之外

官方建议：

- 不与主启动类在同级目录
  - 可以建在主启动类的上级目录下，目的是不让 `@SpringBootApplication` 或 `@ComponentScan` 扫描到
- 该类不要加 `@Configuration` 注解

![image-20240329154535150](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403291557715.png)



```java
public class LoadBalancerConfig {
    @Bean
    ReactorLoadBalancer<ServiceInstance> randomLoadBalancer(Environment environment,
                                                            LoadBalancerClientFactory loadBalancerClientFactory) {
        String name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);
 
        return new RandomLoadBalancer(loadBalancerClientFactory
                .getLazyProvider(name, ServiceInstanceListSupplier.class),
                name);
    }
}
```



```java
@Configuration
@LoadBalancerClient(name = "cloud-payment-service", configuration = LoadBalancerConfig.class)
public class WebClientConfig {
    @Bean
    @LoadBalanced
    public WebClient.Builder loadBalancedWebClientBuilder() {
        return WebClient.builder();
    }
}
```



将`@LoadBalancerClient`或`@LoadBalancerClients`配置类放在组件扫描范围之外，或者不使用`@Configuration`注解，有助于保持配置的清晰性和一致性。这样可以更明确地指出这些类仅用于负载均衡配置，而不是用于定义Spring Bean。

经过测试，将randomLoadBalancer写在@Configuration配置类中依然是可以的。

尽管测试表明这样做可以工作，但这并不是推荐的做法。按照官方文档和最佳实践，通常建议避免将`@LoadBalancerClient`或`@LoadBalancerClients`指定的配置类标记为`@Configuration`，或者确保它们不在组件扫描的路径下，以避免潜在的配置冲突或混淆。

```java
import org.springframework.cloud.client.ServiceInstance;
import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.cloud.loadbalancer.annotation.LoadBalancerClient;
import org.springframework.cloud.loadbalancer.core.RandomLoadBalancer;
import org.springframework.cloud.loadbalancer.core.ReactorLoadBalancer;
import org.springframework.cloud.loadbalancer.core.ServiceInstanceListSupplier;
import org.springframework.cloud.loadbalancer.support.LoadBalancerClientFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.Environment;
import org.springframework.web.reactive.function.client.WebClient;

@Configuration
@LoadBalancerClient(
        //下面的value值大小写一定要和consul里面的名字一样，必须一样
        value = "cloud-payment-service",configuration = WebClientConfig.class)
public class WebClientConfig {

    @Bean
    @LoadBalanced
    public WebClient.Builder loadBalancedWebClientBuilder() {
        return WebClient.builder();
    }

    @Bean
    ReactorLoadBalancer<ServiceInstance> randomLoadBalancer(Environment environment,
                                                            LoadBalancerClientFactory loadBalancerClientFactory) {
        String name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);

        return new RandomLoadBalancer(loadBalancerClientFactory.getLazyProvider(name, ServiceInstanceListSupplier.class), name);
    }
}
```

# 编码实现使用DiscoveryClient动态获取所有上线的服务列表



![image-20240329151411395](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403291557683.png)

在任意注册到consul的服务查看所有上线的服务列表

比如在订单模块OrderController

```java
@Resource
private DiscoveryClient discoveryClient;

@GetMapping("/discovery")
public String discovery() {
    List<String> services = discoveryClient.getServices();
    for (String element : services) {
        System.out.println(element);
    }

    System.out.println("===================================");

    List<ServiceInstance> instances = discoveryClient.getInstances("cloud-payment-service");
    for (ServiceInstance element : instances) {
        System.out.println(element.getServiceId() + "\t" + element.getHost() + "\t" + element.getPort() + "\t" + element.getUri());
    }
    return instances.get(0).getServiceId() + ":" + instances.get(0).getPort();
}
```

访问http://localhost/consumer/pay/discovery  控制台输出

共有三个服务，其中cloud-payment-service服务有两个实例，和consul控制台一致

```shell
cloud-order-service
cloud-payment-service
consul
===================================
cloud-payment-service	192.168.140.1	8001	http://192.168.140.1:8001
cloud-payment-service	192.168.140.1	8002	http://192.168.140.1:8002
```





![image-20240329152054658](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403291557641.png)



页面返回第一个实例为cloud-payment-service:8001，也与Consul控制台一致

![image-20240329152243093](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403291557367.png)

![image-20240329152153784](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403291557877.png)
