# OpenFeign简介

## OpenFeign是什么

Feign是一个**声明性web服务客户端**。它使编写web服务客户端变得更容易。使用Feign创建一个接口并对其进行注释。它具有可插入的注释支持，包括Feign注释和JAX-RS注释。Feign还支持可插拔编码器和解码器。Spring Cloud添加了对Spring MVC注释的支持，以及对使用Spring Web中默认使用的HttpMessageConverter的支持。Spring Cloud集成了Eureka、Spring Cloud CircuitBreaker以及Spring Cloud LoadBalancer，以便在使用Feign时提供负载平衡的http客户端。



![image-20240329162948021](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403291734118.png)

声明一点：内容中提及的feign统一使用的是OpenFeign，Feign已经被OpenFeign所替代

- **Feign**：早期Spring Cloud版本中使用的声明式HTTP客户端，用于简化RESTful Web Service客户端的编写。Feign的核心思想是，将HTTP请求映射成接口，通过调用接口方法的方式，发送HTTP请求。
- **OpenFeign**：在后续版本的Spring Cloud中，Feign被OpenFeign所替代。OpenFeign是Netflix Feign的一个开源分支，它提供了与Feign相似的功能，但在性能和功能上可能有所改进。Spring Cloud OpenFeign为Spring Boot应用程序提供了集成OpenFeign的自动配置。

## OpenFeign能干什么

前面在使用**SpringCloud LoadBalancer**+WebClient时，利用WebClient对http请求的封装处理形成了一套模版化的调用方法。

但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。所以，OpenFeign在此基础上做了进一步封装，由他来帮助我们定义和实现依赖服务接口的定义。在OpenFeign的实现下，我们只需创建一个接口并使用注解的方式来配置它(在一个微服务接口上面标注一个**@FeignClient**注解即可)，即可完成对服务提供方的接口绑定，统一对外暴露可以被调用的接口方法，大大简化和降低了调用客户端的开发量，也即由服务提供者给出调用接口清单，消费者直接通过OpenFeign调用即可。

 

OpenFeign同时还集成SpringCloud LoadBalancer

可以在使用OpenFeign时提供Http客户端的负载均衡，也可以集成阿里巴巴Sentinel来提供熔断、降级等功能。而与SpringCloud LoadBalancer不同的是，通过OpenFeign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用。



# 使用OpenFeign实现服务接口调用

## 如何使用OpenFeign

1.主启动添加@EnableFeignClients启用 Feign 客户端功能

2.创建一个Rest接口并在该接口上添加注解@FeignClient

![image-20240329163310460](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403291734602.png)

## 创建Module cloud-consumer-feign-order80

cloud-consumer-feign-order80 服务消费者

cloud-api-common 公共API模块

cloud-provider-payment8001/8082 服务提供者

![image-20240329164555552](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403291734827.png)

## pom

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.dongguo</groupId>
        <artifactId>SpringCloud</artifactId>
        <version>0.0.1-SNAPSHOT</version>
    </parent>
    <groupId>com.dongguo</groupId>
    <artifactId>cloud-consumer-feign-order80</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>cloud-consumer-feign-order80</name>
    <description>cloud-consumer-feign-order80</description>
    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>
    <dependencies>
        <!-- 引入自己定义的api通用包 -->
        <dependency>
            <groupId>com.dongguo</groupId>
            <artifactId>cloud-api-common</artifactId>
            <version>0.0.1-SNAPSHOT</version>
        </dependency>
        <!--openfeign-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-openfeign</artifactId>
        </dependency>
        <!--SpringCloud consul discovery-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-consul-discovery</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <!--fastjson2-->
        <dependency>
            <groupId>com.alibaba.fastjson2</groupId>
            <artifactId>fastjson2</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>
```

## yml

```yaml
server:
  port: 80

spring:
  application:
    name: cloud-consumer-openfeign-order
  ####Spring Cloud Consul for Service Discovery
  cloud:
    consul:
      host: localhost
      port: 8500
      discovery:
        prefer-ip-address: true #优先使用服务ip进行注册
        service-name: ${spring.application.name}
  # ========================日期格式化=====================
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: GMT-8
# ========================swagger=====================
springdoc:
  swagger-ui:
    enabled: true
    path: /swagger-ui.html
```

## 主启动

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.openfeign.EnableFeignClients;

@SpringBootApplication
@EnableDiscoveryClient //该注解用于向注册中心注册服务
@EnableFeignClients//启用feign客户端,定义服务+绑定接口，以声明式的方法优雅而简单的实现服务调用
public class FeignOrder80Application {

    public static void main(String[] args) {
        SpringApplication.run(FeignOrder80Application.class, args);
        System.out.println("http://127.0.0.1:80/swagger-ui.html");
    }

}
```

## 业务类

### 修改cloud-api-commons通用模块

1.引入openfeign依赖

```xml
<!--openfeign-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
```

2.新建服务接口PayFeignApi,并配置@FeignClient注解

参考微服务8001的Controller层，完成接口方法

```java
import com.dongguo.cloud.entity.DTO.PayDTO;
import com.dongguo.cloud.resp.Result;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.*;

@FeignClient(value = "cloud-payment-service")
public interface PayFeignApi {
    /**
     * 新增一条支付相关流水记录
     *
     * @param payDTO
     * @return
     */
    @PostMapping("/pay/add")
    Result addPay(@RequestBody PayDTO payDTO);

    /**
     * 按照主键记录查询支付流水信息
     *
     * @param id
     * @return
     */
    @GetMapping("/pay/get/{id}")
    Result getById(@PathVariable("id") Integer id);

    /**
     * 按照主键记录删除支付流水信息
     *
     * @param id
     * @return
     */
    @DeleteMapping("/pay/del/{id}")
    Result deletePay(@PathVariable("id") Integer id);

    /**
     * 修改支付流水
     * @param payDTO
     * @return
     */
    @PutMapping("/pay/update")
    Result updatePay(@RequestBody PayDTO payDTO);
    /**
     * openfeign天然支持负载均衡演示
     *
     * @return
     */
    @GetMapping(value = "/pay/get/info")
    Result getInfoByConsul();
}
```

3.重新clean、install cloud-api-commons

### cloud-consumer-feign-order80 创建OrderController

```java
@RestController
@Tag(name = "订单模块", description = "订单控制器接口")
public class OrderController {
    @Resource
    private PayFeignApi payFeignApi;

    @PostMapping("/feign/pay/add")
    @Operation(summary = "新增", description = "新增支付流水,json串做参数")
    public Result addOrder(@RequestBody PayDTO payDTO) {
        System.out.println("第一步：模拟本地addOrder新增订单成功(省略sql操作)，第二步：再开启addPay支付微服务远程调用");
        return payFeignApi.addPay(payDTO);
    }

    @GetMapping("/feign/pay/get/{id}")
    @Operation(summary = "按照ID查流水", description = "查询支付流水")
    public Result getPayInfo(@PathVariable("id") Integer id) {
        System.out.println("-------支付微服务远程调用，按照id查询订单支付流水信息");
        return payFeignApi.getById(id);
    }

    @DeleteMapping("/feign/pay/del/{id}")
    @Operation(summary = "删除", description = "删除支付流水")
    public Result deletePay(@PathVariable("id") Integer id) {
        return payFeignApi.getById(id);
    }

    @PutMapping("/feign/pay/update")
    @Operation(summary = "修改", description = "修改支付流水")
    public Result updatePay(@RequestBody PayDTO payDTO) {
        return payFeignApi.updatePay(payDTO);
    }

    /**
     * openfeign天然支持负载均衡演示
     *
     * @return
     */
    @GetMapping(value = "/feign/pay/get/info")
    @Operation(summary = "验证负载均衡")
    public Result getInfoByConsul() {
        return payFeignApi.getInfoByConsul();
    }
}
```

## 测试

启动8001、8002和feign80

![image-20240329173008945](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403291734023.png)

查询

![image-20240329173126395](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403291734442.png)

当在项目中引入LoadBalancer的依赖，OpenFeign默认集成了LoadBalancer

![image-20240329203851375](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403292040449.png)

验证负载均衡

![image-20240329173211662](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403291734854.png)

![image-20240329173306012](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403291734131.png)

# OpenFeign高级特性

## OpenFeign超时控制

在Spring Cloud微服务架构中，大部分公司都是利用OpenFeign进行服务间的调用，而比较简单的业务使用默认配置是不会有多大问题的，但是如果是业务比较复杂，服务要进行比较繁杂的业务计算，那后台很有可能会出现Read Timeout这个异常，因此定制化配置超时时间就有必要了。



### 模拟超时场景

1.服务提供方cloud-provider-payment8001 

PayController中查询支付流水方法设置睡眠100秒

```java
    @GetMapping(value = "/get/{id}")
    @Operation(
            summary = "按照ID查流水",
            description = "查询支付流水"
    )
    public Result getById(@PathVariable("id") Integer id) {
        Pay pay = payService.getById(id);
        //模拟超时场景
        try {
            TimeUnit.SECONDS.sleep(100);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        return Result.success(pay);
    }
```

2.服务调用方cloud-consumer-feign-order80

OrderController查询支付流水方法捕捉超时异常

```java
    @GetMapping("/feign/pay/get/{id}")
    @Operation(summary = "按照ID查流水", description = "查询支付流水")
    public Result getPayInfo(@PathVariable("id") Integer id) {
        System.out.println("-------支付微服务远程调用，按照id查询订单支付流水信息");
        Result result = null;
        DateTime start = DateUtil.date();
        try {
            System.out.println("调用开始-----:" + start);
            result = payFeignApi.getById(id);
        } catch (Exception e) {
            e.printStackTrace();
            DateTime end = DateUtil.date();
            System.out.println("调用结束-----:" + end);
            System.out.println("发生超时 毫秒值：+" + DateUtil.betweenMs(start, end));
            Result.fail(RC500.getCode(), e.getMessage());
        }
        return result;
    }
```

3.测试

启动cloud-provider-payment8001 、cloud-consumer-feign-order80

![image-20240329205913888](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403301033530.png)

请求查询支付流水接口http://127.0.0.1/feign/pay/get/1，发生超时

```shell
-------支付微服务远程调用，按照id查询订单支付流水信息
调用开始-----:2024-03-29 20:59:38
feign.RetryableException: Read timed out executing GET http://cloud-payment-service/pay/get/1
	at feign.FeignException.errorExecuting(FeignException.java:278)
	at feign.SynchronousMethodHandler.executeAndDecode(SynchronousMethodHandler.java:110)
	at feign.SynchronousMethodHandler.invoke(SynchronousMethodHandler.java:70)
	at feign.ReflectiveFeign$FeignInvocationHandler.invoke(ReflectiveFeign.java:99)
	at jdk.proxy2/jdk.proxy2.$Proxy120.getById(Unknown Source)
	at com.dongguo.cloud.controller.OrderController.getPayInfo(OrderController.java:36)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at 
	......
	... 58 more
调用结束-----:2024-03-29 21:00:38
发生超时 毫秒值：+60119
```

4.结论

OpenFeign默认等待60秒钟，超过后报错Read timed out

### 官网关于超时说明

![image-20240329204150004](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403301033077.png)

默认OpenFeign客户端等待60秒钟，如果服务端处理超过规定时间会导致Feign客户端返回报错。

为了避免这样的情况，有时候我们需要设置Feign客户端的超时控制，默认60秒太长或者业务时间太短都不好



### 超时配置

yml文件中开启配置：

connectTimeout    连接超时时间

readTimeout       请求处理超时时间

修改cloud-consumer-feign-order80YML文件里需要开启OpenFeign客户端超时控制

####  全局配置

![image-20240329210844002](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403301033513.png)

1.default所有feign接口有效

```yaml
    #============Spring Cloud OpenFeign超时控制 ================
spring:
  cloud:
    openfeign:
      client:
        config:
          default:     #default所有feign接口有效
            connectTimeout: 5000  #5000毫秒
            readTimeout: 5000
```

2.测试

```shell
-------支付微服务远程调用，按照id查询订单支付流水信息
调用开始-----:2024-03-29 21:26:16
feign.RetryableException: Read timed out executing GET http://cloud-payment-service/pay/get/1
	at feign.FeignException.errorExecuting(FeignException.java:278)
	at feign.SynchronousMethodHandler.executeAndDecode(SynchronousMethodHandler.java:110)
	at feign.SynchronousMethodHandler.invoke(SynchronousMethodHandler.java:70)
	at feign.ReflectiveFeign$FeignInvocationHandler.invoke(ReflectiveFeign.java:99)
	at jdk.proxy2/jdk.proxy2.$Proxy120.getById(Unknown Source)
	at com.dongguo.cloud.controller.OrderController.getPayInfo(OrderController.java:36)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at 
	.......
	... 58 more
调用结束-----:2024-03-29 21:26:21
发生超时 毫秒值：+5079
```

#### 指定配置

![image-20240329210945630](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403301033008.png)

1.PayFeignApi指定feignName  

@FeignClient(name= "cloud-payment-service")或者@FeignClient(value = "cloud-payment-service")    

attribute 'name' and its alias 'value' are declared with values of [payFeign] and [cloud-payment-service].

```java
@FeignClient(value = "cloud-payment-service")
public interface PayFeignApi {
}
```

2.指定feign接口有效

```yaml
    #============Spring Cloud OpenFeign超时控制 ================
spring:
  cloud:
    openfeign:
      client:
        config:
          cloud-payment-service:  #feignName 指定feign接口有效
            connectTimeout: 5000  #5000毫秒
            readTimeout: 5000
```

3.测试

```shell
-------支付微服务远程调用，按照id查询订单支付流水信息
调用开始-----:2024-03-29 21:23:54
feign.RetryableException: Read timed out executing GET http://cloud-payment-service/pay/get/1
	at feign.FeignException.errorExecuting(FeignException.java:278)
	at feign.SynchronousMethodHandler.executeAndDecode(SynchronousMethodHandler.java:110)
	at feign.SynchronousMethodHandler.invoke(SynchronousMethodHandler.java:70)
	at feign.ReflectiveFeign$FeignInvocationHandler.invoke(ReflectiveFeign.java:99)
	at jdk.proxy2/jdk.proxy2.$Proxy120.getById(Unknown Source)
	at com.dongguo.cloud.controller.OrderController.getPayInfo(OrderController.java:36)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at 
	......
	... 58 more
调用结束-----:2024-03-29 21:23:59
发生超时 毫秒值：+5080
```

## OpenFeign重试机制

 在微服务架构中，服务之间是通过网络进行通信的，而网络又是非常复杂和不稳定的，所以在服务调用的过程中可能会失败或超时，那么在这种情况下，OpenFeign 就需要超时重试机制来解决了。



默认情况下会创建Retryer.NEVER_RETRY类型为Retryer的bean,这将禁用重试机制。

请注意，这种重试行为与Feign默认行为不同，它会自动重试IOExceptions,将它们视为与网络相关的瞬态异常，以及从ErrorDecoder抛出的任何RetryableException。

![image-20240330071729334](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403301033860.png)

1.开启重试机制

![image-20240330074256738](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403301033083.png)

之前我们已经设置了OpenFeign的超时时间，接下来需要配置重试策略

```java
import feign.Retryer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class FeignConfig {
    @Bean
    public Retryer retryer() {
        //return Retryer.NEVER_RETRY; //Feign默认配置是不走重试策略的

        /**
         * period 初始间隔时间为100毫秒
         * maxPeriod 重试间最大间隔时间为1000毫秒（即1秒）
         * maxAttempts 最大请求次数为3
         * 这里的“最大请求次数为3”是指，在发生错误时，Feign发起请求的次数。
         * 第一次请求失败后，会等待100毫秒后重试，如果第二次请求仍然失败，它会等待更长的时间（但不会超过1000毫秒）再次重试，总共尝试3次。
         *
         * 在发生请求失败时，Feign会进行以下尝试：
         * 原始请求（计入重试次数）
         * 第一次重试（等待至少100毫秒）
         * 第二次重试（等待时间根据指数退避策略计算，但不会超过1000毫秒）
         */
        return new Retryer.Default(100, 1, 3);
    }
}
```

2.打印调用时间

为了更直观的显示重试操作，在cloud-provider-payment8001模块打印调用时间

```java
@GetMapping(value = "/get/{id}")
@Operation(
        summary = "按照ID查流水",
        description = "查询支付流水"
)
public Result getById(@PathVariable("id") Integer id) {
    Pay pay = payService.getById(id);
    //模拟超时场景
    try {
        System.out.println("调用时间-----:" + LocalDateTime.now());
        TimeUnit.SECONDS.sleep(100);
    } catch (InterruptedException e) {
        throw new RuntimeException(e);
    }
    return Result.success(pay);
}
```

3.测试

从打印结果来看一共发起了3次请求，共花费15055毫秒

80服务：

```shell
-------支付微服务远程调用，按照id查询订单支付流水信息
调用开始-----:2024-03-30 08:07:21
feign.RetryableException: Read timed out executing GET http://cloud-payment-service/pay/get/1
	at feign.FeignException.errorExecuting(FeignException.java:278)
	at feign.SynchronousMethodHandler.executeAndDecode(SynchronousMethodHandler.java:110)
	at feign.SynchronousMethodHandler.invoke(SynchronousMethodHandler.java:70)
	at feign.ReflectiveFeign$FeignInvocationHandler.invoke(ReflectiveFeign.java:99)
	at jdk.proxy2/jdk.proxy2.$Proxy120.getById(Unknown Source)
	at com.dongguo.cloud.controller.OrderController.getPayInfo(OrderController.java:36)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at 
	......
	... 58 more
调用结束-----:2024-03-30 08:07:36
发生超时 毫秒值：+15055
```

8001服务：

```shell
调用时间-----:2024-03-30T08:07:21.852193400
调用时间-----:2024-03-30T08:07:26.822712300
调用时间-----:2024-03-30T08:07:31.830794800
```

4.分析

Retryer 的 Default 方法源码中重试次数变量 attempt 是从 1 开始的，然后核心方法 continueOrPropagate 中的 if 判断是当 attemp >= maxAttempts 时，才抛出异常。

也就是说maxAttempts就是OpenFeign请求超时重试一共发起的请求次数（如maxAttempts=3，请求一次，重试两次）

也可以从源码看到Retryer.Default()默认的重试策略 this(100, SECONDS.toMillis(1), 5) 

```java
  class Default implements Retryer {

    private final int maxAttempts;
    private final long period;
    private final long maxPeriod;
    int attempt;
    long sleptForMillis;

    public Default() {
      this(100, SECONDS.toMillis(1), 5);
    }

    public Default(long period, long maxPeriod, int maxAttempts) {
      this.period = period;
      this.maxPeriod = maxPeriod;
      this.maxAttempts = maxAttempts;
      this.attempt = 1;
    }

    // visible for testing;
    protected long currentTimeMillis() {
      return System.currentTimeMillis();
    }

    public void continueOrPropagate(RetryableException e) {
      if (attempt++ >= maxAttempts) {
        throw e;
      }

      long interval;
      if (e.retryAfter() != null) {
        interval = e.retryAfter() - currentTimeMillis();
        if (interval > maxPeriod) {
          interval = maxPeriod;
        }
        if (interval < 0) {
          return;
        }
      } else {
        interval = nextMaxInterval();
      }
      try {
        Thread.sleep(interval);
      } catch (InterruptedException ignored) {
        Thread.currentThread().interrupt();
        throw e;
      }
      sleptForMillis += interval;
    }
  }
```

### 自定义超时重试机制

OpenFeign 内置的超时重试机制，它的重试策略是固定次数的重试，而这种策略在某些场景下效果并不理想。

例如我们设置的重试次数为 3，此时因为网络短暂抖动造成了服务调用失败，而固定策略可能在网络恢复前就已经用完了所有的重试次数，这样就导致重试机制的作用不大。有时候我们更需要的是指数增长的重试策略，就像 TCP 的超时重传一样，那种指数增长的重试策略更加的智能，它会在每次重试失败后增加等待时间，给网络或者服务更多的恢复时间，并减少因短时间内多次重试对服务的潜在影响。

1.自定义超时重试类

实现Retryer接口，完成自定义超时重试，注意：CustomRetryer中attempt默认为0，那么maxAttempts设置为几，就会重试几次

```java
import feign.RetryableException;
import feign.Retryer;

import java.time.LocalDateTime;

/**
 * 自定义超时重试类
 */
public class CustomRetryer implements Retryer {
    private final int maxAttempts;  // 最大尝试次数
    private final long backoff;  // 重试间隔时间
    int attempt; // 当前重试次数

    public CustomRetryer() {
        this.maxAttempts = 3;
        this.backoff = 1000L;
        this.attempt = 0; //这里默认为0
    }

    @Override
    public void continueOrPropagate(RetryableException e) {
        if (attempt++ >= maxAttempts) {
            throw e;
        }
        long interval = this.backoff * attempt;// 指数增长
        System.out.println(LocalDateTime.now() + " | 执行第" + attempt + "次重试, 重试间隔时间：" + interval);
        try {
            Thread.sleep(interval);
        } catch (InterruptedException ex) {
            throw new RuntimeException(ex);
        }
    }

    @Override
    public Retryer clone() {
        return new CustomRetryer();
    }
}
```

2.yml 指定自定义超时重试类

自定义超时重试的开关 retryer: com.dongguo.cloud.config.CustomRetryer

```yaml
    #============Spring Cloud OpenFeign超时控制 ================
spring:    
  cloud:  
    openfeign:
      client:
        config:
          default:               #default所有feign接口有效
            connectTimeout: 5000  #5000毫秒
            readTimeout: 5000
            retryer: com.dongguo.cloud.config.CustomRetryer   #自定义超时重试类的包名+ 类名
```

3.测试

从打印结果来看一共发起了4次请求，共花费26134毫秒，重试时间间隔为backoff * attempt

80：

```shell
-------支付微服务远程调用，按照id查询订单支付流水信息
调用开始-----:2024-03-30 09:04:56
2024-03-30T09:05:02.048530800 | 执行第1次重试, 重试间隔时间：1000
2024-03-30T09:05:08.063769800 | 执行第2次重试, 重试间隔时间：2000
2024-03-30T09:05:15.087239600 | 执行第3次重试, 重试间隔时间：3000
feign.RetryableException: Read timed out executing GET http://cloud-payment-service/pay/get/1
	at feign.FeignException.errorExecuting(FeignException.java:278)
	at feign.SynchronousMethodHandler.executeAndDecode(SynchronousMethodHandler.java:110)
	at feign.SynchronousMethodHandler.invoke(SynchronousMethodHandler.java:70)
	at feign.ReflectiveFeign$FeignInvocationHandler.invoke(ReflectiveFeign.java:99)
	at jdk.proxy2/jdk.proxy2.$Proxy120.getById(Unknown Source)
	at com.dongguo.cloud.controller.OrderController.getPayInfo(OrderController.java:36)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at 
	......
	... 58 more
调用结束-----:2024-03-30 09:05:23
发生超时 毫秒值：+26134
```

8001

```
调用时间-----:2024-03-30T09:04:57.095744
调用时间-----:2024-03-30T09:05:03.063314200
调用时间-----:2024-03-30T09:05:10.080017700
调用时间-----:2024-03-30T09:05:18.104407700
```



## OpenFeign HTTP客户端

OpenFeign中http client如果不做特殊配置，OpenFeign默认使用JDK自带的HttpURLConnection发送HTTP请求，

虽然HttpURLConnection是JDK自带的，但它并不支持连接池，因此在高并发场景下可能会导致性能问题。为了提高性能和效率，通常推荐使用带有连接池的HTTP客户端，如Apache HttpClient或OkHttp，来替换默认的HttpURLConnection。这些客户端可以更好地管理HTTP连接，提高请求的处理速度和效率。

可以从超时报错信息里看到使用的是HttpURLConnection

![image-20240330082339530](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403301033019.png)

### 使用Apache HttpClient 5

使用Apache HttpClient 5替换OpenFeign默认的HttpURLConnection

![image-20240330082642721](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403301033763.png)

从Spring Cloud OpenFeign 4开始，不再支持Feign Apache HttpClient 4。官方建议改用Apache HttpClient 5。



1.为了方便测试，取消OpenFeign的重试机制，直接超时报错

```java
import feign.Retryer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class FeignConfig {
    @Bean
    public Retryer retryer() {
        return Retryer.NEVER_RETRY; //Feign不进行重试的实现
    }
}
```



```yaml
    #============Spring Cloud OpenFeign超时控制 ================
spring:    
  cloud:     
    openfeign:
      client:
        config:
          default:               #default所有feign接口有效
            connectTimeout: 5000  #5000毫秒
            readTimeout: 5000
#            retryer: com.dongguo.cloud.config.CustomRetryer   #自定义超时重试类的包名+ 类名
```

2.pom

引入与OpenFeign集成的HttpClient库feign-hc5，通常不需要再额外引入 Apache HttpClient 5 的核心库，因为 `feign-hc5` 会作为传递依赖自动引入它。

但是，为了确保兼容性和避免潜在的版本冲突，建议检查 `feign-hc5` 所依赖的 Apache HttpClient 5 版本，并确保它与你的项目中的其他依赖兼容。

```java
<!-- https://mvnrepository.com/artifact/io.github.openfeign/feign-hc5 -->
<dependency>
    <groupId>io.github.openfeign</groupId>
    <artifactId>feign-hc5</artifactId>
    <version>13.1</version>
</dependency>
```

3.yml

```yam
#  Apache HttpClient5 配置开启
spring:
  cloud:
    openfeign:
      httpclient:
        hc5:
          enabled: true
```

4.测试

已经替换为Apache HttpClient 5

```shell
-------支付微服务远程调用，按照id查询订单支付流水信息
调用开始-----:2024-03-30 09:56:02
feign.RetryableException: Read timed out executing GET http://cloud-payment-service/pay/get/1
	at feign.FeignException.errorExecuting(FeignException.java:278)
	at feign.SynchronousMethodHandler.executeAndDecode(SynchronousMethodHandler.java:110)
	at feign.SynchronousMethodHandler.invoke(SynchronousMethodHandler.java:70)
	at feign.ReflectiveFeign$FeignInvocationHandler.invoke(ReflectiveFeign.java:99)
	at jdk.proxy2/jdk.proxy2.$Proxy120.getById(Unknown Source)
	at com.dongguo.cloud.controller.OrderController.getPayInfo(OrderController.java:36)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at 
	......
Caused by: java.net.SocketTimeoutException: Read timed out
	at java.base/sun.nio.ch.NioSocketImpl.timedRead(NioSocketImpl.java:283)
	at java.base/sun.nio.ch.NioSocketImpl.implRead(NioSocketImpl.java:309)
	at java.base/sun.nio.ch.NioSocketImpl.read(NioSocketImpl.java:350)
	at java.base/sun.nio.ch.NioSocketImpl$1.read(NioSocketImpl.java:803)
	at java.base/java.net.Socket$SocketInputStream.read(Socket.java:966)
	at org.apache.hc.core5.http.impl.io.SessionInputBufferImpl.fillBuffer(SessionInputBufferImpl.java:149)
	at org.apache.hc.core5.http.impl.io.SessionInputBufferImpl.readLine(SessionInputBufferImpl.java:280)
	at org.apache.hc.core5.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:247)
	at org.apache.hc.core5.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:54)
	at org.apache.hc.core5.http.impl.io.DefaultBHttpClientConnection.receiveResponseHeader(DefaultBHttpClientConnection.java:299)
	at org.apache.hc.core5.http.impl.io.HttpRequestExecutor.execute(HttpRequestExecutor.java:175)
	at org.apache.hc.core5.http.impl.io.HttpRequestExecutor.execute(HttpRequestExecutor.java:218)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager$InternalConnectionEndpoint.execute(PoolingHttpClientConnectionManager.java:712)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.execute(InternalExecRuntime.java:216)
	at org.apache.hc.client5.http.impl.classic.MainClientExec.execute(MainClientExec.java:116)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:188)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:87)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at feign.hc5.ApacheHttp5Client.execute(ApacheHttp5Client.java:89)
	at org.springframework.cloud.openfeign.loadbalancer.LoadBalancerUtils.executeWithLoadBalancerLifecycleProcessing(LoadBalancerUtils.java:56)
	at org.springframework.cloud.openfeign.loadbalancer.LoadBalancerUtils.executeWithLoadBalancerLifecycleProcessing(LoadBalancerUtils.java:91)
	at org.springframework.cloud.openfeign.loadbalancer.FeignBlockingLoadBalancerClient.execute(FeignBlockingLoadBalancerClient.java:134)
	at feign.SynchronousMethodHandler.executeAndDecode(SynchronousMethodHandler.java:100)
	... 58 more
调用结束-----:2024-03-30 09:56:08
发生超时 毫秒值：+5106
```



## OpenFeign日志打印

Feign 提供了日志打印功能，我们可以通过配置来调整日志级别，从而了解 Feign 中 Http 请求的细节，

说白了就是对Feign接口的调用情况进行监控和输出

 

OpenFeign提供了4种日志级别：

NONE：默认的，不显示任何日志；

BASIC：仅记录请求方法、URL、响应状态码及执行时间；

HEADERS：除了 BASIC 中定义的信息之外，还有请求和响应的头信息；

FULL：除了 HEADERS 中定义的信息之外，还有请求和响应的正文及元数据。

```java
/**
 * Controls the level of logging.
 */
public enum Level {
  /**
   * No logging.
   */
  NONE,
  /**
   * Log only the request method and URL and the response status code and execution time.
   */
  BASIC,
  /**
   * Log the basic information along with request and response headers.
   */
  HEADERS,
  /**
   * Log the headers, body, and metadata for both requests and responses.
   */
  FULL
}
```



![image-20240330101412072](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403301032666.png)

1.配置日志bean

设置Feign客户端的日志级别， Logger.Level.FULL：Feign将记录关于请求和响应的完整信息，包括请求和响应的头部和体。

```java
import feign.Logger;
import feign.Retryer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class FeignConfig {
    @Bean
    public Retryer retryer() {
        return Retryer.NEVER_RETRY; //Feign不进行重试的实现
    }

    @Bean
    Logger.Level feignLoggerLevel() {
        return Logger.Level.FULL;
    }
}
```

2.配置需要开启日志的Feign客户端

仅仅设置 `FeignConfig` 类中的日志级别是不够的，因为你需要告诉Feign哪些客户端接口需要记录日志，以及这些日志的级别是什么。

**logging.level** + 含有@FeignClient注解的完整带包名的接口名+debug

将`com.dongguo.cloud.feign.PayFeignApi`这个Feign客户端接口的日志级别设置为`DEBUG`。这样，Feign就会记录这个接口相关的DEBUG级别及以上的日志信息。

```yml
# feign日志以什么级别监控哪个接口
logging:
  level:
    com:
      dongguo:
        cloud:
          feign:
            PayFeignApi: debug
```

3.测试

控制台打印出调用com.dongguo.cloud.feign.PayFeignApi的信息

```shell
-------支付微服务远程调用，按照id查询订单支付流水信息
调用开始-----:2024-03-30 10:16:17
2024-03-30T10:16:17.596+08:00 DEBUG 27068 --- [cloud-consumer-openfeign-order] [p-nio-80-exec-4] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#getById] ---> GET http://cloud-payment-service/pay/get/1 HTTP/1.1
2024-03-30T10:16:17.596+08:00 DEBUG 27068 --- [cloud-consumer-openfeign-order] [p-nio-80-exec-4] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#getById] ---> END HTTP (0-byte body)
2024-03-30T10:16:22.721+08:00 DEBUG 27068 --- [cloud-consumer-openfeign-order] [p-nio-80-exec-4] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#getById] <--- ERROR SocketTimeoutException: Read timed out (5125ms)
2024-03-30T10:16:22.722+08:00 DEBUG 27068 --- [cloud-consumer-openfeign-order] [p-nio-80-exec-4] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#getById] java.net.SocketTimeoutException: Read timed out
	at java.base/sun.nio.ch.NioSocketImpl.timedRead(NioSocketImpl.java:283)
	at java.base/sun.nio.ch.NioSocketImpl.implRead(NioSocketImpl.java:309)
	at java.base/sun.nio.ch.NioSocketImpl.read(NioSocketImpl.java:350)
	at java.base/sun.nio.ch.NioSocketImpl$1.read(NioSocketImpl.java:803)
	at java.base/java.net.Socket$SocketInputStream.read(Socket.java:966)
	at org.apache.hc.core5.http.impl.io.SessionInputBufferImpl.fillBuffer(SessionInputBufferImpl.java:149)
	at org.apache.hc.core5.http.impl.io.SessionInputBufferImpl.readLine(SessionInputBufferImpl.java:280)
	at org.apache.hc.core5.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:247)
	at org.apache.hc.core5.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:54)
	at 
	......

2024-03-30T10:16:22.723+08:00 DEBUG 27068 --- [cloud-consumer-openfeign-order] [p-nio-80-exec-4] com.dongguo.cloud.feign.PayFeignApi      : [PayFeignApi#getById] <--- END ERROR
调用结束-----:2024-03-30 10:16:22
发生超时 毫秒值：+5136
feign.RetryableException: Read timed out executing GET http://cloud-payment-service/pay/get/1
	at feign.FeignException.errorExecuting(FeignException.java:278)
	at feign.SynchronousMethodHandler.executeAndDecode(SynchronousMethodHandler.java:110)
	at feign.SynchronousMethodHandler.invoke(SynchronousMethodHandler.java:70)
	at feign.ReflectiveFeign$FeignInvocationHandler.invoke(ReflectiveFeign.java:99)
	at jdk.proxy2/jdk.proxy2.$Proxy120.getById(Unknown Source)
	at com.dongguo.cloud.controller.OrderController.getPayInfo(OrderController.java:36)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at 
	......
	... 58 more
```



## OpenFeign请求/响应压缩

![image-20240330100318544](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403301032185.png)

**对请求和响应进行GZIP压缩**

Spring Cloud OpenFeign支持对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗。

通过下面的两个参数设置，就能开启请求与相应的压缩功能：

```properties
spring.cloud.openfeign.compression.request.enabled=true
spring.cloud.openfeign.compression.response.enabled=true
```

 

**细粒度化设置**

对请求压缩做一些更细致的设置，比如下面的配置内容指定压缩的请求数据类型并设置了请求压缩的大小下限，

只有超过这个大小的请求才会进行压缩：

```properties
spring.cloud.openfeign.compression.request.enabled=true
spring.cloud.openfeign.compression.request.mime-types=text/xml,application/xml,application/json #触发压缩数据类型
spring.cloud.openfeign.compression.request.min-request-size=2048 #最小触发压缩的大小
```



1.yml

```yaml
spring:
  cloud:
    openfeign:
      compression:
        request:
          enabled: true
          min-request-size: 2048 #最小触发压缩的大小
          mime-types: text/xml,application/xml,application/json #触发压缩数据类型
        response:
          enabled: true
```

2.测试

日志中多出的内容：

客户端（也就是发起Feign请求的服务）告诉服务器它支持`gzip`和`deflate`这两种压缩算法。如果服务器支持这些压缩算法，它可以选择使用其中一种来压缩响应内容，以减少传输的数据量。

![image-20240330102712801](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403301032740.png)

