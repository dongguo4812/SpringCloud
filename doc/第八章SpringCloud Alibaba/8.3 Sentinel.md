Sentinel简介

http://sentinelguard.io/zh-cn/

![image-20240404111657783](F:\note\image\image-20240404111657783.png)

随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 是面向分布式、多语言异构化服务架构的流量治理组件，主要以流量为切入点，从流量路由、流量控制、流量整形、熔断降级、系统自适应过载保护、热点流量防护等多个维度来帮助开发者保障微服务的稳定性。

##  Sentinel的特征

丰富的应用场景：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。

完备的实时监控：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。

广泛的开源生态：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Apache Dubbo、gRPC、Quarkus 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。同时 Sentinel 提供 Java/Go/C++ 等多语言的原生实现。

完善的 SPI 扩展机制：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。

## Sentinel的主要特性

![features-of-sentinel](https://github.com/alibaba/Sentinel/raw/1.8/doc/image/sentinel-features-overview-en.png)

## 分布式系统面临的问题

服务雪崩

解决方案：

服务降级

服务熔断

服务限流

服务隔离

服务超时

.......

这些已经在CircuitBreaker中提及

# 安装Sentinel

Sentinel 的使用可以分为两个部分:

- 核心库（Java 客户端）：不依赖任何框架/库，能够运行于 Java 8 及以上的版本的运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持（见 [主流框架适配](https://sentinelguard.io/zh-cn/docs/open-source-framework-integrations.html)）。后台默认8719
- 控制台（Dashboard）：Dashboard 主要负责管理推送规则、监控、管理机器信息等。前台8080开启



## 1.下载Sentinel

https://github.com/alibaba/Sentinel/releases

最新版本1.8.7,下载jar

![image-20240404140627925](F:\note\image\image-20240404140627925.png)

## 2.运行Sentinel

运行Sentinel需要JDK 1.8 或更高版本

在Sentinel所在目录使用cmd命令`java -jar sentinel-dashboard-1.8.7.jar`

![image-20240404141642800](F:\note\image\image-20240404141642800.png)

3.访问Sentinel管理界面http://localhost:8080，登录账号密码均为sentinel

![image-20240404141759037](F:\note\image\image-20240404141759037.png)

# Sentinel入门

## 创建Module

cloud-alibaba-sentinel-service8401

## pom

```xml
<dependencies>
    <!--SpringCloud alibaba sentinel -->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
    </dependency>
    <!--nacos-discovery-->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
    </dependency>
    <!-- 引入自己定义的api通用包 -->
    <dependency>
        <groupId>com.dongguo</groupId>
        <artifactId>cloud-api-common</artifactId>
        <version>0.0.1-SNAPSHOT</version>
    </dependency>
    <!--SpringBoot通用依赖模块-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    <!--hutool-->
    <dependency>
        <groupId>cn.hutool</groupId>
        <artifactId>hutool-all</artifactId>
    </dependency>
    <!--lombok-->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <version>1.18.28</version>
        <scope>provided</scope>
    </dependency>
    <!--test-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
```



## yml

```yaml
server:
  port: 8401

spring:
  application:
    name: cloud-alibaba-sentinel-service
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848         #Nacos服务注册中心地址
    sentinel:
      transport:
        dashboard: localhost:8080 #配置Sentinel dashboard控制台服务地址
        port: 8719 #默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口
```

## 主启动

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@SpringBootApplication
@EnableDiscoveryClient
public class SentinelService8401Application {

    public static void main(String[] args) {
        SpringApplication.run(SentinelService8401Application.class, args);
    }

}
```

## 业务类

创建FlowLimitController

```java
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class FlowLimitController {

    @GetMapping("/testA")
    public String testA() {
        return "------testA";
    }

    @GetMapping("/testB")
    public String testB() {
        return "------testB";
    }
}
```

## 测试

前提：启动Nacos、Sentinel

1.启动微服务8401并访问

2.查看Sentinel控制台

Sentinel采用懒加载机制，所以当前还是没有相关接口，Sentinel对某个接口进行限流和降级等操作，一定要先访问下接口，使Sentinel检测出相应的接口

![image-20240404143009894](F:\note\image\image-20240404143009894.png)

3.访问http://localhost:8401/testA

![image-20240404143134869](F:\note\image\image-20240404143134869.png)

http://localhost:8401/testB

![image-20240404143157493](F:\note\image\image-20240404143157493.png)

4.刷新Sentinel控制台

![image-20240404143308649](F:\note\image\image-20240404143308649.png)

# 流控规则

Sentinel能够对流量进行控制，主要是监控应用的QPS流量或者并发线程数等指标，如果达到指定的阈值时，就会被流量进行控制，以避免服务被瞬时的高并发流量击垮，保证服务的高可靠性。

新增流控规则：



![image-20240404143426330](F:\note\image\image-20240404143426330.png)

相关参数说明：

![image-20240404143500568](F:\note\image\image-20240404143500568.png)



| 1资源名   | 资源的唯一名称，默认就是请求的接口路径，可以自行修改，但是要保证唯一。 |
| --------- | ------------------------------------------------------------ |
| 2针对来源 | 具体针对某个微服务进行限流，默认值为default，表示不区分来源，全部限流。 |
| 3阈值类型 | QPS表示通过QPS进行限流，并发线程数表示通过并发线程数限流。   |
| 4单机阈值 | 与阈值类型组合使用。如果阈值类型选择的是QPS，表示当调用接口的QPS达到阈值时，进行限流操作。如果阈值类型选择的是并发线程数，则表示当调用接口的并发线程数达到阈值时，进行限流操作。 |
| 5是否集群 | 选中则表示集群环境，不选中则表示非集群环境。                 |



![image-20240404151445748](F:\note\image\image-20240404151445748.png)

## 流控模式

流控模式有三个模式：直接、关联、链路

### 直接

默认的流控模式，当接口达到限流条件时，直接开启限流功能。

![image-20240404143919284](F:\note\image\image-20240404143919284.png)

当前配置表示1秒钟内查询1次就是OK，若超过次数1，就直接-快速失败，报默认错误

#### 测试

快速访问http://localhost:8401/testA

![image-20240404144012597](F:\note\image\image-20240404144012597.png)

"Blocked by Sentinel (flow limiting)" 是 Sentinel 在执行流量控制操作时返回的一个默认错误信息。这个错误意味着当前的请求被 Sentinel 拦截了，原因是它超出了系统设定的流量限制。

但是我们在项目中一般都会配置服务降级，提供fallback方法。

服务降级将会在后续实现。

### 关联

当关联的资源到达阈值时，就限流当前接口

![image-20240404144918018](F:\note\image\image-20240404144918018.png)

当关联资源/testB的qps阀值超过1时，就限流/testA的访问

#### 测试

快速访问http://localhost:8401/testB，后访问http://localhost:8401/testA

![image-20240404145158924](F:\note\image\image-20240404145158924.png)

testB的访问超过阈值，testB不会被限流，testA被限流

### 链路

来自不同链路的请求对同一个目标访问时，实施针对性的不同限流措施，比如C请求来访问就限流，D请求来访问就通过

#### yml修改

新增web-context-unify: false

```yaml
server:
  port: 8401

spring:
  application:
    name: cloud-alibaba-sentinel-service
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848         #Nacos服务注册中心地址
    sentinel:
      transport:
        dashboard: localhost:8080 #配置Sentinel dashboard控制台服务地址
        port: 8719 #默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口
      web-context-unify: false # controller层的方法对service层调用不认为是同一个根链路
```

#### 业务类

新建两个接口访问同一个方法



新建FlowLimitService，提供方法common()

```java
import com.alibaba.csp.sentinel.annotation.SentinelResource;
import org.springframework.stereotype.Service;

@Service
public class FlowLimitService {
    @SentinelResource(value = "common")
    public void common() {
        System.out.println("------FlowLimitService come in");
    }
}
```

FlowLimitController新增两个接口，调用FlowLimitService的common()

```java
    /**
     * 流控-链路演示demo
     * C和D两个请求都访问flowLimitService.common()方法，阈值到达后对C限流，对D不管
     */
    @Resource
    private FlowLimitService flowLimitService;

    @GetMapping("/testC")
    public String testC() {
        flowLimitService.common();
        return "------testC";
    }

    @GetMapping("/testD")
    public String testD() {
        flowLimitService.common();
        return "------testD";
    }
```

#### 新增Sentinel配置

资源名是流控规则的基础，它唯一标识一个被保护的服务单元。资源名的填写方式有两种：

1. **请求的URL**：如果是基于Web请求的资源，资源名可以填写为对应的URL，例如与@GetMapping、RequestMapping的value值相对应。
2. **@SentinelResource的value值**：对于其他类型的资源，可以通过@SentinelResource注解的value属性来指定资源名。

@SentinelResource用于标记需要进行资源保护、流量控制、熔断降级等操作的方法或类。通过这个注解，开发者可以方便地定义资源的名称，并关联相应的控制策略。

![image-20240404150804803](F:\note\image\image-20240404150804803.png)

#### 测试

快速访问http://localhost:8401/testD，没有被限流

![image-20240404152039117](F:\note\image\image-20240404152039117.png)

快速访问http://localhost:8401/testC，被限流，返回响应码500

![image-20240404152133701](F:\note\image\image-20240404152133701.png)

## 流控效果-QPS

流控效果有三个选择：快速失败、预热Warm Up 、排队等待

### 快速失败

默认的流控处理，直接抛出异常Blocked by Sentinel (flow limiting)

### Warm Up

在系统启动时先限制一定的流量，然后逐步放开限制，直到系统达到一个稳定的状态。Warm Up模式还提供了一个预热时长参数，用于控制系统进入稳定状态所需的时间。

如：秒杀系统在开启的瞬间，会有很多流量上来，很有可能把系统打死，预热方式就是把为了保护系统，可慢慢的把流量放进来，慢慢的把阈值增长到设置的阈值。

![image-20240404194231001](F:\note\image\image-20240404194231001.png)

公式：阈值threshold除以冷却因子coldFactor，经过预热时长后才会达到阈值

默认 `coldFactor` 为 3，即请求 QPS 从 `threshold / 3` 开始，经预热时长逐渐升至设定的 QPS 阈值。



案例，单机阈值为10，预热时长设置5秒。

系统初始化的阈值为10 / 3 约等于3,即单机阈值刚开始为3(我们人工设定单机阈值是10，sentinel计算后QPS判定为3开始)；

然后过了5秒后阀值才慢慢升高恢复到设置的单机阈值10，也就是说5秒钟内QPS为3，过了保护期5秒后QPS为10

![image-20240404191513372](F:\note\image\image-20240404191513372.png)

在系统启动或流量突然增加时，通过逐步放开限流的方式，让系统平稳过渡到稳定状态。因此，即使停止一段时间后再次请求，系统仍然会按照Warm Up模式的规则进行流量控制，即在预热时长内逐步增加流量限制。

。新增保存后，5秒内阈值为3，快速访问http://localhost:8401/testB

![image-20240404191640962](F:\note\image\image-20240404191640962.png)

5秒后阈值到达10，访问http://localhost:8401/testB就很难达到阈值。

![image-20240404192523279](F:\note\image\image-20240404192523279.png)

### 排队等待

匀速排队，让请求以均匀的速度通过，阀值类型必须设成QPS，否则无效。

![image-20240404194258742](F:\note\image\image-20240404194258742.png)

FlowLimitController新增方法打印请求毫秒值

```java
    @GetMapping("/testE")
    public String testE() {
        System.out.println(System.currentTimeMillis() + "      testE,排队等待");
        return "------testE";
    }
```

![image-20240404194750920](F:\note\image\image-20240404194750920.png)

JMeter模拟发送请求，20个线程在1秒内同时请求

![image-20240404201916566](F:\note\image\image-20240404201916566.png)

![image-20240404201926032](F:\note\image\image-20240404201926032.png)

按照单机阈值，一秒钟通过一个请求，请求超过10秒后，作为超时处理，直接放弃

![image-20240404201809016](F:\note\image\image-20240404201809016.png)

## 流控效果-并发线程数

testE接口并发线程数1，只能有一个线程来处理请求。换句话说，如果有多个请求同时到达，那么只有一个请求会被立即处理，而其他请求将会被阻塞或排队等待，直到当前处理的线程空闲出来（根据流控模式决定）。

![image-20240404203059698](F:\note\image\image-20240404203059698.png)

### 测试

JMeter无限循环请求/testE

![image-20240404202906805](F:\note\image\image-20240404202906805.png)

使用浏览器请求，同时有两个线程请求，请求直接限流

![image-20240404202850454](F:\note\image\image-20240404202850454.png)

# 熔断规则

https://github.com/alibaba/Sentinel/wiki/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7

除了流量控制以外，对调用链路中不稳定的资源进行熔断降级也是保障高可用的重要措施之一。一个服务常常会调用别的模块，可能是另外的一个远程服务、数据库，或者第三方 API 等。例如，支付的时候，可能需要远程调用银联提供的 API；查询某个商品的价格，可能需要进行数据库查询。然而，这个被依赖服务的稳定性是不能保证的。如果依赖的服务出现了不稳定的情况，请求的响应时间变长，那么调用服务的方法的响应时间也会变长，线程会产生堆积，最终可能耗尽业务自身的线程池，服务本身也变得不可用。

![image-20240404204619365](F:\note\image\image-20240404204619365.png)

Sentinel控制台

![image-20240404204702222](F:\note\image\image-20240404204702222.png)



## 熔断策略

![image-20240404204718824](F:\note\image\image-20240404204718824.png)

Sentinel 提供以下几种熔断策略：

- 慢调用比例 (`SLOW_REQUEST_RATIO`)：选择以慢调用比例作为阈值，需要设置允许的慢调用 RT（即最大的响应时间），请求的响应时间大于该值则统计为慢调用。当单位统计时长（`statIntervalMs`）内请求数目大于设置的最小请求数目，并且慢调用的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求响应时间小于设置的慢调用 RT 则结束熔断，若大于设置的慢调用 RT 则会再次被熔断。
- 异常比例 (`ERROR_RATIO`)：当单位统计时长（`statIntervalMs`）内请求数目大于设置的最小请求数目，并且异常的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是 `[0.0, 1.0]`，代表 0% - 100%。
- 异常数 (`ERROR_COUNT`)：当单位统计时长内的异常数目超过阈值之后会自动进行熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。

## 慢调用比例

FlowLimitController新增慢调用比例接口

```java
/**
 * 新增熔断规则-慢调用比例
 *
 * @return
 */
@GetMapping("/testF")
public String testF() {
    //暂停几秒钟线程
    try {
        TimeUnit.SECONDS.sleep(1);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println("----测试:新增熔断规则-慢调用比例 ");
    return "------testF 新增熔断规则-慢调用比例";
}
```

### Sentinel配置

![image-20240404205354927](F:\note\image\image-20240404205354927.png)

进入熔断状态判断依据：在统计时长内，实际请求数目＞设定的最小请求数  且   实际慢调用比例＞比例阈值 ，进入熔断状态。

1.调用：一个请求发送到服务器，服务器给与响应，一个响应就是一个调用。

2.最大RT：即最大的响应时间，指系统对请求作出响应的业务处理时间。

3.慢调用：处理业务逻辑的实际时间>设置的最大RT时间，这个调用叫做慢调用。

4.慢调用比例：在所以调用中，慢调用占有实际的比例＝慢调用次数➗总调用次数

5.比例阈值：自己设定的 ， 比例阈值＝慢调用次数➗调用次数

6.统计时长：时间的判断依据

7.最小请求数：设置的调用最小请求数，上图比如1秒钟打进来10个线程（大于我们配置的5个了）调用被触发

![image-20240404210144503](F:\note\image\image-20240404210144503.png)

### 使用JMeter压测

![image-20240404205906391](F:\note\image\image-20240404205906391.png)



![image-20240404205917856](F:\note\image\image-20240404205917856.png)

10个线程，在一秒的时间内发送完。又因为服务器响应时长设置：暂停1秒，所以响应一个请求的时长都大于1秒综上符合熔断条件，所以当线程开启1秒后，进入熔断状态



**多次循环，一秒钟打进来10个线程(大于5个了)调用/testF，我们希望200毫秒处理完一次调用，**

**假如在统计时长内，实际请求数目＞最小请求数且慢调用比例＞比例阈值 ，断路器打开(保险丝跳闸)微服务不可用(Blocked by Sentinel (flow limiting))，进入熔断状态5秒；**

单独访问http://localhost:8401/testF，被熔断

![image-20240404205954295](F:\note\image\image-20240404205954295.png)



后续我停止jmeter，没有这么大的访问量了，单独用浏览器访问rest地址，断路器关闭(保险丝恢复，合上闸口)，

![image-20240404210037231](F:\note\image\image-20240404210037231.png)

## 异常比例

![image-20240404210207749](F:\note\image\image-20240404210207749.png)

FlowLimitController新增异常比例接口

```java
    /**
     * 新增熔断规则-异常比例
     *
     * @return
     */
    @GetMapping("/testG")
    public String testG() {
        System.out.println("----测试:新增熔断规则-异常比例 ");
        int age = 10 / 0;
        return "------testG,新增熔断规则-异常比例 ";
    }
```

如果使用springboot的@RestControllerAdvice全局异常捕获，那么设置sentinel的异常数熔断规则就会失效，去github上看sentinel的Issues发现已经有人提过这问题，官方也是没有正面回复

![在这里插入图片描述](https://img-blog.csdnimg.cn/144b85aaf7d7477990bf8d31938626c7.png)



![在这里插入图片描述](https://img-blog.csdnimg.cn/b0e8c00d8de7452cabbcf80452e31bcd.png)

因为Sentinel的熔断规则是基于异常数统计的。
为了解决这个问题，你可以在全局异常处理器中手动调用Sentinel的统计接口，将异常信息传递给Sentinel进行统计。具体来说，你可以在@ExceptionHandler方法中使用Tracer.trace(ex)方法将异常信息传递给Sentinel进行统计。例如：

```java
import com.alibaba.csp.sentinel.Tracer;
import com.dongguo.cloud.resp.Result;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import static com.dongguo.cloud.resp.ReturnCodeEnum.RC500;


@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {
    /**
     * 默认全局异常处理。
     *
     * @param e the e
     * @return ResultData
     */
    @ExceptionHandler(RuntimeException.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public Result<String> exception(Exception e) {
        System.out.println("----come in GlobalExceptionHandler");
        log.error("全局异常信息exception:{}", e.getMessage(), e);
        // 记录异常信息到Sentinel中
        Tracer.trace(e);
        return Result.fail(RC500.getCode(), e.getMessage());
    }
}
```

注意：这种情况是发生在使用sentinel控制台直接在资源上设置的规则，如果使用注解`@SentinelResource`标记熔断限流资源，不受影响，因为注解里标明了具体fallback

### Sentinel配置

![image-20240404210352287](F:\note\image\image-20240404210352287.png)

不配置Sentinel，对于int age=10/0，调一次错一次报错error，页面报【Whitelabel Error Page】或全局异常

![image-20240404211008639](F:\note\image\image-20240404211008639.png)

配置Sentinel，对于int age=10/0，如符合如下异常比例启动熔断，页面报【Blocked by Sentinel (flow limiting)】

![image-20240404212650573](F:\note\image\image-20240404212650573.png)

停止Jmeter，等待五秒后，再次访问

![image-20240404212716007](F:\note\image\image-20240404212716007.png)

## 异常数

![image-20240404212741377](F:\note\image\image-20240404212741377.png)

注意：时间窗口一定要大于等于60秒。  异常数是按照分钟统计的

FlowLimitController新增异常数接口

```java
    /**
     * 新增熔断规则-异常数
     *
     * @return
     */
    @GetMapping("/testH")
    public String testH() {
        System.out.println("----测试:新增熔断规则-异常数 ");
        int age = 10 / 0;
        return "------testH,新增熔断规则-异常数 ";
    }
```

Sentinel配置

![image-20240404213441101](F:\note\image\image-20240404213441101.png)

http://localhost:8401/testH，第一次访问绝对报错，因为除数不能为零，我们看到error窗口；

![](F:\note\image\image-20240404213602767.png)



JMeter压测

![image-20240404213506849](F:\note\image\image-20240404213506849.png)

但是jmeter开工，上述配置表示，在1秒钟内最少请求2次，当异常数大于1时，会触发熔断操作断路器开启(保险丝跳闸)，微服务不可用了，熔断的时长为5秒，不再报错error而是服务降级了出提示Blocked by Sentinel (flow limiting) 

![image-20240404213730960](F:\note\image\image-20240404213730960.png)

五秒后，再次访问。

![image-20240404213809921](F:\note\image\image-20240404213809921.png)

# @SentinelResource注解

https://sentinelguard.io/zh-cn/docs/annotation-support.html

在流控规则的流控模式-链路中，有使用到@SentinelResource注解的value属性来指定资源名。

![image-20240404150804803](F:\note\image\image-20240404150804803.png)

`@SentinelResource`是Sentinel框架中的一个注解，它用于定义需要进行流量控制、熔断降级等限流措施的资源。这个注解可以应用于方法或类级别，允许开发者为特定的资源配置限流策略、熔断降级策略等。

`@SentinelResource`注解的主要作用是：

1. **资源保护**：防止流量过大时导致的系统崩溃，确保系统的稳定性。
2. **资源隔离**：实现资源之间的流量隔离，避免资源之间的互相影响。
3. **流量控制**：根据系统的负载情况，对流量进行控制，确保系统的稳定性

源码：

```java
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
public @interface SentinelResource {

    //资源名称
    String value() default "";

    //entry类型，标记流量的方向，取值IN/OUT，默认是OUT
    EntryType entryType() default EntryType.OUT;
    //资源分类
    int resourceType() default 0;

    //处理BlockException的函数名称,函数要求：
    //1. 必须是 public
    //2.返回类型 参数与原方法一致
    //3. 默认需和原方法在同一个类中。若希望使用其他类的函数，可配置blockHandlerClass ，并指定blockHandlerClass里面的方法。
    String blockHandler() default "";

    //存放blockHandler的类,对应的处理函数必须static修饰。
    Class<?>[] blockHandlerClass() default {};

    //用于在抛出异常的时候提供fallback处理逻辑。 fallback函数可以针对所
    //有类型的异常（除了 exceptionsToIgnore 里面排除掉的异常类型）进行处理。函数要求：
    //1. 返回类型与原方法一致
    //2. 参数类型需要和原方法相匹配
    //3. 默认需和原方法在同一个类中。若希望使用其他类的函数，可配置fallbackClass ，并指定fallbackClass里面的方法。
    String fallback() default "";

    //存放fallback的类。对应的处理函数必须static修饰。
    String defaultFallback() default "";

    //用于通用的 fallback 逻辑。默认fallback函数可以针对所有类型的异常进
    //行处理。若同时配置了 fallback 和 defaultFallback，以fallback为准。函数要求：
    //1. 返回类型与原方法一致
    //2. 方法参数列表为空，或者有一个 Throwable 类型的参数。
    //3. 默认需要和原方法在同一个类中。若希望使用其他类的函数，可配置fallbackClass ，并指定 fallbackClass 里面的方法。
    Class<?>[] fallbackClass() default {};
 

    //需要trace的异常
    Class<? extends Throwable>[] exceptionsToTrace() default {Throwable.class};

    //指定排除忽略掉哪些异常。排除的异常不会计入异常统计，也不会进入fallback逻辑，而是原样抛出。
    Class<? extends Throwable>[] exceptionsToIgnore() default {};
}
```

使用`@SentinelResource`注解时，可以为其配置一些参数，如资源名称、限流阈值、流控模式、熔断降级策略等。这些参数的具体配置可以在注解中进行，也可以根据需要在Sentinel控制台进行动态调整。

`@SentinelResource`注解还提供了可选的异常处理和`fallback`配置项，用于指定出现异常时的处理策略。这使得开发者可以更加灵活地应对可能出现的异常情况，确保系统的健壮性。

即：我们可以通过@SentinelResource注解和Sentinel控制台配置协同使用，更加灵活的来进行流量控制和限流。

## 不使用@SentinelResource注解

在Sentinel控制台中通过访问的rest地址来限流，会返回Sentinel自带默认的限流处理信息

### 新增RateLimitController

```java
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;


@RestController
@Slf4j
public class RateLimitController {
    @GetMapping("/rateLimit/byUrl")
    public String byUrl() {
        return "按rest地址限流测试OK";
    }
}
```

Sentinel懒加载，需要请求一次才会出现接口内容

![image-20240405082405448](F:\note\image\image-20240405082405448.png)

访问http://localhost:8401/rateLimit/byUrl

![image-20240405082501487](F:\note\image\image-20240405082501487.png)

### Sentinel控制台配置



![image-20240405082612223](F:\note\image\image-20240405082612223.png)

进行流控配置

![image-20240405082643506](F:\note\image\image-20240405082643506.png)

快速访问http://localhost:8401/rateLimit/byUrl，会返回Sentinel默认的限流处理结果， Blocked by Sentinel (flow limiting)

![image-20240405082732320](F:\note\image\image-20240405082732320.png)

## 使用@SentinelResource自定义限流提示

不想用默认的限流提示（Blocked by Sentinelflow limiting))，想返回自定义限流的提示



RateLimitController新增

```java
    @GetMapping("/rateLimit/byResource")
    @SentinelResource(value = "byResourceSentinelResource", blockHandler = "handleException")
    public String byResource() {
        return "按资源名称SentinelResource限流测试OK";
    }

    public String handleException(BlockException exception) {
        return "@SentinelResource自定义限流提示:服务不可用";
    }
```

同样，先访问一下接口http://localhost:8401/rateLimit/byResource

![image-20240405084040437](F:\note\image\image-20240405084040437.png)

### Sentinel控制台

@SentinelResource(value = "byResourceSentinelResource", blockHandler = "handleException") ；找到名为byResourceSentinelResource的资源

![image-20240405084210034](F:\note\image\image-20240405084210034.png)

配置

![image-20240405084231995](F:\note\image\image-20240405084231995.png)

快速访问http://localhost:8401/rateLimit/byResource

![image-20240405084253640](F:\note\image\image-20240405084253640.png)

## 使用@SentinelResource自定义限流提示并提供服务降级方法

按SentinelResource配置，点击超过限流配置返回自定义限流提示+程序异常返回fallback服务降级



RateLimitController新增

```java
    @GetMapping("/rateLimit/doAction/{p1}")
    @SentinelResource(value = "doActionSentinelResource",
            blockHandler = "doActionBlockHandler", fallback = "doActionFallback")
    public String doAction(@PathVariable("p1") Integer p1) {
        if (p1 == 0) {
            throw new RuntimeException("p1等于零直接异常");
        }
        return "doAction";
    }

    public String doActionBlockHandler(@PathVariable("p1") Integer p1, BlockException e) {
        log.error("sentinel配置自定义限流:{}", e);
        return "sentinel配置自定义限流";
    }

    public String doActionFallback(@PathVariable("p1") Integer p1, Throwable e) {
        log.error("程序逻辑异常了:{}", e);
        return "服务降级：程序逻辑异常了" + "\t" + e.getMessage();
    }
```

同样，先访问一下接口http://localhost:8401/rateLimit/doAction/1

![image-20240405084911721](F:\note\image\image-20240405084911721.png)

### Sentinel配置

![image-20240405084938444](F:\note\image\image-20240405084938444.png)

配置

![image-20240405085001241](F:\note\image\image-20240405085001241.png)

快速访问http://localhost:8401/rateLimit/doAction/1，触发限流

![image-20240405085033318](F:\note\image\image-20240405085033318.png)

访问http://localhost:8401/rateLimit/doAction/0，出现异常，服务降级

![image-20240405085103767](F:\note\image\image-20240405085103767.png)

# 热点规则

何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行限制。比如：

- 商品 ID 为参数，统计一段时间内最常购买的商品 ID 并进行限制
- 用户 ID 为参数，针对一段时间内频繁访问的用户 ID 进行限制

热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。

![image-20240405091555325](F:\note\image\image-20240405091555325.png)

Sentinel 利用 LRU 策略统计最近最常访问的热点参数，结合令牌桶算法来进行参数级别的流控。

## 正常热点限流

含有P1参数，超过1秒钟一个后，达到阈值1后马上被限流

RateLimitController新增：

```java
    @GetMapping("/testHotKey")
    @SentinelResource(value = "testHotKey", blockHandler = "dealHandler_testHotKey")
    public String testHotKey(@RequestParam(value = "p1", required = false) String p1,
                             @RequestParam(value = "p2", required = false) String p2) {
        return "------testHotKey";
    }

    public String dealHandler_testHotKey(String p1, String p2, BlockException exception) {
        return "-----dealHandler_testHotKey";
    }
```

访问http://localhost:8401/testHotKey

![image-20240405105626468](F:\note\image\image-20240405105626468.png)

### Sentinel配置

![image-20240405105737471](F:\note\image\image-20240405105737471.png)

配置

![image-20240405105757661](F:\note\image\image-20240405105757661.png)

限流模式只支持QPS模式，固定写死了。（这才叫热点）

@SentinelResource注解的方法参数索引，0代表第一个参数，1代表第二个参数，以此类推

单机阀值以及统计窗口时长表示在此窗口时间超过阀值就限流。

当前配置就是第一个参数有值的话，1秒的QPS为1，超过就限流，限流后调用dealHandler_testHotKey支持方法。

 sentinel系统默认的提示：Blocked by Sentinel (flow limiting

1.快速访问http://localhost:8401/testHotKey?p1=abc，含有参数P1，当每秒访问的频率超过1次时，会触发Sentinel的限流操作

![image-20240405105937927](F:\note\image\image-20240405105937927.png)

2.快速访问http://localhost:8401/testHotKey?p1=abc&p2=123，含有参数P1，当每秒访问的频率超过1次时，会触发Sentinel的限流操作

![image-20240405110025970](F:\note\image\image-20240405110025970.png)

3.快速访问http://localhost:8401/testHotKey?p2=123，没有热点参数P1，不断访问则不会触发限流操作

![image-20240405110101952](F:\note\image\image-20240405110101952.png)

## 特殊热点限流

我们期望p1参数当它是某个特殊值时，它的限流值和其他值不一样，假如当p1的值等于5时，它的阈值可以达到200

![image-20240405110719804](F:\note\image\image-20240405110719804.png)

点击添加

![image-20240405110650550](F:\note\image\image-20240405110650550.png)

参数类型指定String类型才有效

频繁访问http://localhost:8401/testHotKey?p1=1，当p1不等于5的时候，阈值就是平常的【普通正常限流】规则

![image-20240405110753098](F:\note\image\image-20240405110753098.png)

频繁访问http://localhost:8401/testHotKey?p1=5，当p1等于5的时候，阈值变为200，一秒内达到阈值200后才会被限流

![image-20240405110817058](F:\note\image\image-20240405110817058.png)

# 授权规则

https://sentinelguard.io/zh-cn/docs/system-adaptive-protection.html

在某些场景下，需要根据调用接口的来源判断是否允许执行本次请求。此时就可以使用Sentinel提供的授权规则来实现，Sentinel的授权规则能够根据请求的来源判断是否允许本次请求通过。

在Sentinel的授权规则中，提供了 白名单与黑名单 两种授权类型。白放行、黑禁止

2.创建EmpowerController

```java
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * Empower授权规则，用来处理请求的来源
 */
@RestController
@Slf4j
public class EmpowerController {
    @GetMapping(value = "/empower")
    public String requestSentinel4() {
        log.info("测试Sentinel授权规则empower");
        return "Sentinel授权规则";
    }
}
```

MyRequestOriginParser：

为了使 Sentinel 的授权规则生效，通常需要提供一个 `RequestOriginParser` 的实现，这样 Sentinel 才能知道如何从 HTTP 请求中提取请求来源。

```java
import com.alibaba.csp.sentinel.adapter.spring.webmvc.callback.RequestOriginParser;
import jakarta.servlet.http.HttpServletRequest;
import org.springframework.stereotype.Component;

/**
 *自定义的请求来源解析器（RequestOriginParser）。这个解析器的主要功能是从HTTP请求中提取特定的参数，
 */
@Component
public class MyRequestOriginParser implements RequestOriginParser {
    @Override
    public String parseOrigin(HttpServletRequest httpServletRequest) {
        return httpServletRequest.getParameter("serverName");
    }
} 
```

访问http://localhost:8401/empower

![image-20240405113013379](F:\note\image\image-20240405113013379.png)

## Sentinel配置

![image-20240405113051983](F:\note\image\image-20240405113051983.png)

配置

![image-20240405113118787](F:\note\image\image-20240405113118787.png)

授权规则用于根据调用来源（即资源的请求来源）来限制资源是否可以通过。授权规则可以配置为白名单模式或黑名单模式。



访问http://localhost:8401/empower?serverName=test1

![image-20240405113251269](F:\note\image\image-20240405113251269.png)

访问http://localhost:8401/empower?serverName=test2

![image-20240405113310056](F:\note\image\image-20240405113310056.png)

访问http://localhost:8401/empower?serverName=abc

![image-20240405113858991](F:\note\image\image-20240405113858991.png)

# 规则持久化

一旦我们重启微服务应用，sentinel规则将消失，生产环境需要将配置规则进行持久化

![image-20240405120404695](F:\note\image\image-20240405120404695.png)

我们可以将限流配置规则持久化进Nacos保存，只要刷新8401某个请求，sentinel控制台的流控规则就能看到 。只要Nacos里面的配置不删除 ，针对8401上sentinel上的流控规则持续有效。

## cloud-alibaba-sentinel-service8401

### pom

`sentinel-datasource-nacos` 是 Sentinel 为 Nacos 扩展的数据源模块，允许将规则数据存储在 Nacos 配置中心。在微服务启动时，Sentinel 会自动在 Nacos 下载对应的规则数据。

```xml
        <!--SpringCloud ailibaba sentinel-datasource-nacos -->
        <dependency>
            <groupId>com.alibaba.csp</groupId>
            <artifactId>sentinel-datasource-nacos</artifactId>
        </dependency>
```

### yml

```yml
server:
  port: 8401

spring:
  application:
    name: cloud-alibaba-sentinel-service
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848         #Nacos服务注册中心地址
    sentinel:
      transport:
        dashboard: localhost:8080 #配置Sentinel dashboard控制台服务地址
        port: 8719 #默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口
      web-context-unify: false # controller层的方法对service层调用不认为是同一个根链路
      datasource:
        ds1:
          nacos:
            server-addr: localhost:8848
            dataId: ${spring.application.name}
            groupId: DEFAULT_GROUP
            data-type: json
            rule-type: flow # com.alibaba.cloud.sentinel.datasource.RuleType
```

- 配置了Sentinel从Nacos获取流量控制规则，这些规则以json格式存储在Nacos中，并使用了`cloud-alibaba-sentinel-service`作为dataId。

rule-type：

流量控制规则 FlowRule

熔断降级规则 DegradeRule

访问控制规则 AuthorityRule

系统保护规则 SystemRule

热点规则ParamFlowRule

![image-20240405120607285](F:\note\image\image-20240405120607285.png)



### Nacos新建Sentinel的规则配置

![image-20240405121020654](F:\note\image\image-20240405121020654.png)



```json
[
    {
        "resource": "/rateLimit/byUrl",
        "limitApp": "default",
        "grade": 1,
        "count": 1,
        "strategy": 0,
        "controlBehavior": 0,
        "clusterMode": false
    }
]
```

resource：资源名称；

limitApp：来源应用；

grade：阈值类型，0表示线程数，1表示QPS；

count：单机阈值；strategy：流控模式，0表示直接，1表示关联，2表示链路；

controlBehavior：流控效果，0表示快速失败，1表示Warm Up，2表示排队等待；

clusterMode：是否集群。

### 启动cloud-alibaba-sentinel-service8401

访问http://localhost:8401/rateLimit/byUrl后，查看Sentinel控制台，已经生成了在Nacos中配置的业务规则

![image-20240405122143307](F:\note\image\image-20240405122143307.png)

### 停止cloud-alibaba-sentinel-service8401

查看Sentinel控制台，已在Nacos中配置的业务规则已经没有了

![image-20240405122307388](F:\note\image\image-20240405122307388.png)

### 启动cloud-alibaba-sentinel-service8401

查看Sentinel控制台，已在Nacos中配置的业务规则还是没有了

![image-20240405122410447](F:\note\image\image-20240405122410447.png)

访问http://localhost:8401/rateLimit/byUrl后，查看Sentinel控制台，在Nacos中配置的业务规则又出现了

![image-20240405122444576](F:\note\image\image-20240405122444576.png)

# OpenFeign和Sentinel集成实现服务降级

之前cloud-alibaba-consumer-nacos-order90  调用  cloud-alibaba-provider-payment9001是通过WebClient实现的。

现在实现cloud-alibaba-consumer-nacos-order90  通过OpenFeign调用  cloud-alibaba-provider-payment9001并解决统一服务降级

## 分析

1. 如果和之前一样，每个方法都要加一个fallback方法，那肯定是不行的。

![image-20240405125350874](F:\note\image\image-20240405125350874.png)

可以通过@FeignClient注解，使用fallback属性进行统一配置，feign接口里面定义的全部方法都走统一的服务降级，**一个fallback方法搞定即可**。

2.9001微服务还需要实现sentinel内部配置的流控规则，如果满足也会被触发

即需要完成的任务

 1 OpenFeign接口的统一fallback服务降级处理

 2 Sentinel访问触发了自定义的限流配置,在注解@SentinelResource里面配置的blockHandler方法。

## cloudalibaba-provider-payment9001

























































# GateWay和Sentinel集成实现服务降流

