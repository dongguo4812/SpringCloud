# 支付服务provider8001注册进consul

## pom添加consul依赖

```xml
<!--SpringCloud consul discovery -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-consul-discovery</artifactId>
</dependency>
```

## application.yml添加consul配置

```yaml
####Spring Cloud Consul for Service Discovery
spring:
  cloud:
    consul:
      host: localhost
      port: 8500
      discovery:
        service-name: ${spring.application.name}
```

## 主启动@EnableDiscoveryClient启用服务发现功能

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import tk.mybatis.spring.annotation.MapperScan;

@SpringBootApplication
@MapperScan("com.dongguo.cloud.mapper") //import tk.mybatis.spring.annotation.MapperScan;
@EnableDiscoveryClient
public class Payment8001Application {

	public static void main(String[] args) {
		SpringApplication.run(Payment8001Application.class, args);
		System.out.println("http://127.0.0.1:8001/swagger-ui.html");
	}
}
```

## 启动8001并查看consul控制台

![image-20240328200716872](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403282105798.png)

# 订单服务consumer80注册进consul

与provider8001同

## pom添加consul依赖

```xml
        <!--SpringCloud consul discovery -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-consul-discovery</artifactId>
        </dependency>
```

## application.yml添加consul配置

```yaml
  ####Spring Cloud Consul for Service Discovery
spring:  
  cloud:
    consul:
      host: localhost
      port: 8500
      discovery:
        prefer-ip-address: true #优先使用服务ip进行注册
        service-name: ${spring.application.name}
```

## 主启动@EnableDiscoveryClient启用服务发现功能

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@SpringBootApplication
@EnableDiscoveryClient
public class Order80Application {

    public static void main(String[] args) {
        SpringApplication.run(Order80Application.class, args);
        System.out.println("http://127.0.0.1:80/swagger-ui.html");
    }
}
```

## 业务类

OrderController：

```java
//    public static final String PAYMENT_SERVICE_URL = "http://localhost:8001";//先写死，硬编码
    public static final String PAYMENT_SERVICE_URL = "http://cloud-payment-service";//服务注册中心上的微服务名称
```

## 启动80并查看consul控制台

![image-20240328201547335](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403282105421.png)

# 访问测试

![image-20240328201640475](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403282105893.png)

80后端报错Caused by: java.net.UnknownHostException: Failed to resolve 'cloud-payment-service' [A(1), AAAA(28)] after 3 queries 

在stackoverflow找到解决方案：

https://stackoverflow.com/questions/72569019/java-net-unknownhostexception-failed-to-resolve-inventory-service-after-4-que/77677939

![image-20240328210126116](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403282105038.png)

以及官网给出的示例代码

![image-20240329142231865](F:\note\image\image-20240329142231865.png)



在Spring Cloud中，`@LoadBalanced`注解通常用于`RestTemplate`的自定义配置，以便启用服务发现和负载均衡功能。然而，对于`WebClient`来说，情况稍有不同。尽管Spring Cloud支持对`WebClient`的负载均衡，但是配置的方式略有差异。

对于`WebClient`，需要创建一个带有`@LoadBalanced`注解的`WebClient.Builder` bean，然后在需要的地方注入这个builder来创建`WebClient`实例。这样，Spring Cloud会自动配置这个builder来使用负载均衡。

## 修改WebClientConfig

```java
import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.reactive.function.client.WebClient;

@Configuration
public class WebClientConfig {

//    @Bean
//    @LoadBalanced
//    public WebClient webClient(){
//        return WebClient.builder().build();
//    }

    @Bean
    @LoadBalanced
    public WebClient.Builder loadBalancedWebClientBuilder() {
        return WebClient.builder();
    }
}
```

## controller

```java
import com.dongguo.cloud.entity.DTO.PayDTO;
import com.dongguo.cloud.resp.Result;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.reactive.function.client.WebClient;


@RestController
@RequestMapping("/consumer/pay")
@Tag(name = "订单模块", description = "订单控制器接口")
public class OrderController {
//    public static final String PAYMENT_SERVICE_URL = "http://localhost:8001";//先写死，硬编码
    public static final String PAYMENT_SERVICE_URL = "http://cloud-payment-service";//服务注册中心上的微服务名称
//    @Autowired
//    private WebClient webClient;
    @Autowired
    private WebClient.Builder webClientBuilder;

    /**
     * 一般情况下，通过浏览器的地址栏输入url，发送的只能是get请求
     * 我们底层调用的是post方法，模拟消费者发送get请求，客户端消费者
     * 参数可以不添加@RequestBody
     *
     * @param payDTO
     * @return
     */
    @PostMapping("/add")
    @Operation(summary = "新增", description = "新增支付流水,json串做参数")
    public Result addOrder(@RequestBody PayDTO payDTO) {
        String url = PAYMENT_SERVICE_URL + "/pay/add";
        return webClientBuilder.build().post().uri(url).contentType(MediaType.APPLICATION_JSON).bodyValue(payDTO).retrieve().bodyToMono(Result.class).block();
    }

    @GetMapping("/get/{id}")
    @Operation(summary = "按照ID查流水", description = "查询支付流水")
    public Result getPayInfo(@PathVariable("id") Integer id) {
        String url = PAYMENT_SERVICE_URL + "/pay/get/" + id;
        return webClientBuilder.build().get().uri(url).retrieve().bodyToMono(Result.class).block();
    }

    @GetMapping(value = "/del/{id}")
    @Operation(summary = "删除", description = "删除支付流水")
    public Result deletePay(@PathVariable("id") Integer id) {
        String url = PAYMENT_SERVICE_URL + "/pay/del/" + id;
        return webClientBuilder.build().delete().uri(url).retrieve().bodyToMono(Result.class).block();
    }

    @PutMapping(value = "/update")
    @Operation(summary = "修改", description = "修改支付流水")
    public Result updatePay(@RequestBody PayDTO payDTO) {
        String url = PAYMENT_SERVICE_URL + "/pay/update";
        return webClientBuilder.build().put().uri(url).contentType(MediaType.APPLICATION_JSON).bodyValue(payDTO).retrieve().bodyToMono(Result.class).block();
    }
}
```



## 重启后再次访问成功

![image-20240328210250933](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403282106446.png)

# 主流注册中心异同点

以下是一些常用的注册中心，以及它们与 Spring Boot 3 的集成情况：

1. **Nacos**：
   Nacos 是阿里巴巴开源的一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。它提供了服务发现、动态配置管理和服务元数据等功能。Spring Boot 3 可以通过引入相应的依赖和配置，轻松集成 Nacos 作为注册中心和配置中心。
2. **Consul**：
   Consul 是一个服务网格解决方案，提供全功能的服务发现、配置、分段和安全性。它内置了服务注册与发现的功能，可以与 Spring Cloud 集成，从而与 Spring Boot 3 配合使用。
3. **Eureka**：
   Eureka 是 Netflix 开源的一个服务注册与发现的组件，常与 Spring Cloud 配合使用。虽然 Eureka 2.x 版本后没有继续更新，但 Spring Cloud 仍支持旧版本的 Eureka，因此 Spring Boot 3 项目中理论上也可以使用 Eureka 作为注册中心。不过，考虑到 Eureka 的更新状态，建议在新的项目中考虑使用其他更活跃的注册中心。
4. **Zookeeper**：
   Zookeeper 是一个分布式协调服务，也可以用来实现服务注册与发现的功能。虽然它本身不是专门为微服务架构设计的注册中心，但可以通过一些开源项目（如 Dubbo）与 Spring Boot 集成，从而实现服务注册与发现。

## 注册中心的Ap与CP权衡

1.Nacos既支持AP（可用性优先）模式也支持CP（一致性优先）模式。

- 在AP模式下，Nacos采用了Raft协议，底层数据存储与Raft协议对应，以保证一致性。这种模式更侧重于服务的可用性，即使在网络分区的情况下，也能确保服务的高可用性。
- 在CP模式下，Nacos采用了Distro协议，底层数据存储与阿里自研的Distro协议对应，以保证性能。这种模式更强调数据的一致性，即使在某些情况下可能会影响服务的可用性。

2.Consul在提供分布式系统的服务发现与配置功能时，通过一系列的设计和实现来权衡一致性和可用性。

**写一致性**：

- Consul使用Raft协议来确保数据的一致性。Raft是一个为管理分布式日志而设计的共识算法，通过选举出一个领导者（Leader）来接收所有写请求，并将变更同步给其他跟随者（Follower）。这种机制确保了数据在多数节点上的强一致性。
- Consul的写操作（如服务注册、配置更新等）通常需要在领导者节点上完成，并经过Raft协议的复制和提交过程，以保证数据的一致性。

**可用性**：

- Consul具有高可用性的设计特点。它采用主从模式进行部署，并通过RPC调用（如HTTP和DNS）进行集群间的通信。即使部分节点出现故障，Consul也能通过剩余的健康节点继续提供服务。
- Consul能够自动检测服务的健康状态，并在发现异常时进行故障转移。这种机制确保了服务的持续可用性，即使在某些节点失效的情况下也能保证服务的高可用性。
- Consul还支持负载均衡，根据服务的负载情况来分配请求，确保请求可以平均分布到不同的提供者上，从而提高整个系统的性能和可靠性。

3.Eureka强调服务的可用性，即使在面临网络分区等故障时，也能保证服务的发现和调用能力。为了实现高可用性，Eureka客户端会缓存服务注册表的信息，这样即使Eureka服务端出现问题或网络分区发生，客户端仍然可以使用缓存的信息进行服务调用。

4.Zookeeper通过其内部机制，如ZAB协议和全局有序性，确保了在分布式环境中数据的一致性。这意味着无论客户端连接到哪个节点，都能获取到最新的、一致的数据

在追求一致性的同时，Zookeeper在某些极端情况下可能会牺牲一定的可用性。特别是在网络分区发生时，为了保持数据的一致性，Zookeeper可能会暂时拒绝一些服务请求，直到分区问题解决。这可能导致一些服务在分区期间无法被正常发现和调用。



## AP与CP的理解

### AP

当网络分区出现后，为了保证可用性，系统B可以返回旧值，保证系统的可用性。

当数据出现不一致时，虽然A, B上的注册信息不完全相同，但每个Eureka节点依然能够正常对外提供服务，这会出现查询服务信息时如果请求A查不到，但请求B就能查到。如此保证了可用性但牺牲了一致性结论：违背了一致性C的要求，只满足可用性和分区容错，即AP

![image-20240329064645140](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403290647260.png)





### CP

当网络分区出现后，为了保证一致性，**就必须拒接请求**，否则无法保证一致性，Consul 遵循CAP原理中的CP原则，保证了强一致性和分区容错性，且使用的是Raft算法，比zookeeper使用的Paxos算法更加简单。虽然保证了强一致性，但是可用性就相应下降了，例如服务注册的时间会稍长一些，因为 Consul 的 raft 协议要求必须过半数的节点都写入成功才认为注册成功 ；在leader挂掉了之后，重新选举出leader之前会导致Consul 服务不可用。结论：违背了可用性A的要求，只满足一致性和分区容错，即CP

![image-20240329064709111](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403290647171.png)