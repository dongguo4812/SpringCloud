# 创建Module

前面已经创建了支付模块cloud-provider-payment8001，

接下来创建订单模块cloud-consumer-order80

# 修改pom

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.dongguo</groupId>
        <artifactId>SpringCloud</artifactId>
        <version>0.0.1-SNAPSHOT</version>
    </parent>
    <groupId>com.dongguo</groupId>
    <artifactId>cloud-consumer-order80</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>cloud-consumer-order80</name>
    <description>cloud-consumer-order80</description>
    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>
    <dependencies>
        <!--web + actuator-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <!--lombok-->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <!--hutool-all-->
        <dependency>
            <groupId>cn.hutool</groupId>
            <artifactId>hutool-all</artifactId>
        </dependency>
        <!--fastjson2-->
        <dependency>
            <groupId>com.alibaba.fastjson2</groupId>
            <artifactId>fastjson2</artifactId>
        </dependency>
        <!-- swagger3 调用方式 http://你的主机IP:port/swagger-ui/index.html -->
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>
```

# 配置application.yml

```yaml
server:
  port: 80
```

# 主启动

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Order80Application {

    public static void main(String[] args) {
        SpringApplication.run(Order80Application.class, args);
    }

}
```

# 业务类

将支付模块的PayDTO、ReturnCodeEnum、Result类复制到订单模块

## RestTemplate远程接口调用

由于支付模块和订单模块是不同的服务，服务之间需要通过远程接口调用进行通信。

传统情况下，在服务端代码里访问 `http` 服务时，一般会使用 `JDK` 的 `HttpURLConnection` 或者 `Apache` 的 `HttpClient`，不过这种方法使用起来太过繁琐，而且 `api` 使用起来非常的复杂，还得操心资源回收。

这里可以选择RestTemplate实现远程接口调用，它仅仅只是在 `HTTP` 客户端库（例如 `JDK HttpURLConnection`，`Apache HttpComponents`，`okHttp` 等）基础上，封装了更加简单易用的模板方法 API，方便程序员利用已提供的模板方法发起网络请求和处理，能很大程度上提升我们的开发效率

官网：https://docs.spring.io/spring-framework/docs/6.1.5/javadoc-api/org/springframework/web/client/RestTemplate.html

**RestTemplate是Spring从3.0版本开始提供的**。它是一个访问远程Http服务的工具，提供了常见的REST请求方案的模版，能够大大提高客户端的编写效率。RestTemplate默认依赖jdk的HTTP连接工具。它支持多种HTTP请求方法，如GET、POST、PUT和DELETE等，并提供了相应的操作方法，如getForEntity、getForObject、postForEntity、postForObject等，方便用户进行远程HTTP服务的调用。



### 配置类

将`RestTemplate`配置初始化为一个`Bean`

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;


@Configuration
public class RestTemplateConfig {
    /**
     * 没有实例化RestTemplate时，初始化RestTemplate
     * @return
     */
    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}

```

注意，这种初始化方法，是使用了`JDK`自带的`HttpURLConnection`作为底层`HTTP`客户端实现。

当然，我们还可以修改`RestTemplate`默认的客户端，例如将其改成`HttpClient`客户端，方式如下：

Spring Boot 3 会自动配置一个使用 HttpClient 5 的 `RestTemplateBuilder`

RestTemplateConfig：

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;


@Configuration
public class RestTemplateConfig {

    @Autowired
    private RestTemplateBuilder restTemplateBuilder;

    @Bean
    public RestTemplate restTemplate() {
        // 使用 RestTemplateBuilder 创建一个 RestTemplate 实例
        return restTemplateBuilder.build();
    }
}
```



### controller

```java
import com.dongguo.cloud.common.resp.Result;
import com.dongguo.cloud.entity.DTO.PayDTO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.client.RestTemplate;


@RestController
@RequestMapping("/consumer/pay")
public class OrderController {
    public static final String PAYMENT_SERVICE_URL = "http://localhost:8001";//先写死，硬编码
    @Autowired
    private RestTemplate restTemplate;

    /**
     * 一般情况下，通过浏览器的地址栏输入url，发送的只能是get请求
     * 我们底层调用的是post方法，模拟消费者发送get请求，客户端消费者
     * 参数可以不添加@RequestBody
     *
     * @param payDTO
     * @return
     */
    @GetMapping("/add")
    public Result addOrder(@RequestBody PayDTO payDTO) {
        String url = PAYMENT_SERVICE_URL + "/pay/add";
        return restTemplate.postForObject(url, payDTO, Result.class);
    }

    @GetMapping("/get/{id}")
    public Result getPayInfo(@PathVariable("id") Integer id) {
        String url = PAYMENT_SERVICE_URL + "/pay/get/" + id;
        return restTemplate.getForObject(url, Result.class, id);
    }

    @GetMapping(value = "/del/{id}")
    public Result deletePay(@PathVariable("id") Integer id) {
        String url = PAYMENT_SERVICE_URL + "/pay/del/" + id;
        restTemplate.delete(url, id);
        return Result.success();
    }

    @GetMapping(value = "/update")
    public Result updatePay(@RequestBody PayDTO payDTO) {
        String url = PAYMENT_SERVICE_URL + "/pay/update";
        restTemplate.put(url, payDTO);
        return Result.success();
    }
}
```

### postman测试

启动支付模块8001，启动订单模块80，使用postman测试远程接口调用

http://localhost:80/consumer/pay/get/1

![image-20240328142251949](https://gitee.com/dongguo4812_admin/image/raw/master/image/202403281423683.png)

## WebClient

恭喜你前面又学会了一个过时的知识点，Spring Boot 3.x对HTTP客户端的使用进行了重大改进，并推荐使用`WebClient`作为默认的同步和异步HTTP客户端。`WebClient`是基于Reactive Streams和Project Reactor构建的，它提供了非阻塞的、响应式的编程模型。

`RestTemplate`在Spring Boot 3.x中仍然可用，但是被标记为过时（deprecated），并计划在将来的版本中移除。因此，如果你正在使用或计划使用Spring Boot 3.x，那么推荐的做法是使用`WebClient`而不是`RestTemplate`。

### 配置类

WebClientConfig:

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.reactive.function.client.WebClient;
@Configuration
public class WebClientConfig {
    @Bean
    public WebClient webClient(){
        return WebClient.builder().build();
    }
}
```

### controller

```java
import com.dongguo.cloud.common.resp.Result;
import com.dongguo.cloud.entity.DTO.PayDTO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.reactive.function.client.WebClient;


@RestController
@RequestMapping("/consumer/pay")
public class OrderController {
    public static final String PAYMENT_SERVICE_URL = "http://localhost:8001";//先写死，硬编码
    @Autowired
    private WebClient webClient;

    /**
     * 一般情况下，通过浏览器的地址栏输入url，发送的只能是get请求
     * 我们底层调用的是post方法，模拟消费者发送get请求，客户端消费者
     * 参数可以不添加@RequestBody
     *
     * @param payDTO
     * @return
     */
    @PostMapping("/add")
    public Result addOrder(@RequestBody PayDTO payDTO) {
        String url = PAYMENT_SERVICE_URL + "/pay/add";
        return webClient.post()
                .uri(url)
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(payDTO)
                .retrieve()
                .bodyToMono(Result.class)
                .block();
    }

    @GetMapping("/get/{id}")
    public Result getPayInfo(@PathVariable("id") Integer id) {
        String url = PAYMENT_SERVICE_URL + "/pay/get/" + id;
        return webClient.get()
                .uri(url)
                .retrieve()
                .bodyToMono(Result.class)
                .block();
    }

    @GetMapping(value = "/del/{id}")
    public Result deletePay(@PathVariable("id") Integer id) {
        String url = PAYMENT_SERVICE_URL + "/pay/del/" + id;
        return webClient.delete()
                .uri(url)
                .retrieve()
                .bodyToMono(Result.class)
                .block();
    }

    @PutMapping(value = "/update")
    public Result updatePay(@RequestBody PayDTO payDTO) {
        String url = PAYMENT_SERVICE_URL + "/pay/update";
        return webClient.put()
                .uri(url)
                .contentType(MediaType.APPLICATION_JSON).bodyValue(payDTO)
                .retrieve()
                .bodyToMono(Result.class)
                .block();
    }
}
```

### 测试

![image-20240328163227645](F:\note\image\image-20240328163227645.png)