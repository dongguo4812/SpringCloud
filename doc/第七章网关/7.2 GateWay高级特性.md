# Route实现动态路由

在上一节中，我们路由映射的URI配置是写死的

![image-20240402104425026](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032003.png)

GateWay提供了动态获取服务URI的功能，使得路由不依赖于具体的IP和端口。这一功能通常借助于服务注册中心来实现。Gateway可以从注册中心获取微服务的可用列表，以注册中心上微服务名为路径创建动态路由进行转发，从而实现动态路由的功能

对于使用`lb://`（表示负载均衡）前缀来指定服务URI，如`uri: lb://cloud-payment-service`

![image-20240402110606650](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032797.png)

## cloud-gateway9999 

yml：

将uri: http://localhost:8001 替换为uri: lb://cloud-payment-service

![image-20240402114250322](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032145.png)

## 测试

**重启网关9527,80/8001保持不变**，访问http://localhost/feign/pay/gateway/get/1

![image-20240402111513457](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032723.png)

如果将8001微服务yml文件端口修改为8007

![image-20240402111628581](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032696.png)

等待cloud-payment-service服务注册到consul中，访问http://localhost/feign/pay/gateway/get/1

![image-20240402111657330](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032130.png)

端口名改为8007，依然能够成功访问



这里需要强调一下，`uri: lb://cloud-payment-service` 指Gateway 使用客户端负载均衡来解析服务名 `cloud-payment-service` 到具体的服务实例。

`lb://` 前缀是 Spring Cloud 为客户端负载均衡提供的一个特殊协议。当 Spring Cloud Gateway 遇到这样的 URI 时，它会查找配置的负载均衡器（可能是 `spring-cloud-loadbalancer`，也可能是其他兼容的负载均衡库），并使用这个负载均衡器来解析服务名到具体的服务实例。

![image-20240402134147510](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032885.png)

默认情况下`discovery.locator.enabled: false`  是禁用了 Spring Cloud Gateway 内置的服务发现定位器功能，这意味着 Gateway 不会尝试从服务注册中心（如 Eureka、Consul 等）自动获取服务实例信息来创建路由。但是，这并不影响 Gateway 使用其他已经配置的负载均衡机制来解析服务名。

# Predicate断言

![image-20240402134920676](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032514.png)

Spring Cloud Gateway作为Spring WebFlux HandlerMapping基础设施的一部分来匹配路由。Spring Cloud Gateway包含许多内置的路由断言工厂。所有这些断言都是基于HTTP请求的不同属性进行匹配的。你可以将多个路由断言工厂通过逻辑与语句组合在一起。



在启动微服务gateway9999看到IDEA后台的输出，Spring Cloud Gateway 创建 Route 对象时， 使用 RoutePredicateFactory 创建 Predicate 对象，Predicate 对象可以赋值给 Route。 Spring Cloud Gateway 包含许多内置的Route Predicate Factories。

![image-20240402135433742](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032587.png)Gateway 服务在启动时，会加载和注册一系列的路由断言工厂（RoutePredicateFactory）。这些断言工厂用于定义路由规则，根据HTTP请求的特定属性（如请求头、请求方法、路径等)来决定是否应该将请求路由到特定的服务或端点。

RoutePredicateFactory：

下面会挨个介绍

![image-20240402145804644](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022034800.png)



## Route Predicate

在Spring Cloud Gateway中，配置断言（predicates）和过滤器（filters）有两种主要方式：使用快捷方式（shortcuts）和完全展开的参数方式（fully expanded arguments）。快捷方式提供了一种简洁的方法来快速配置常见的断言和过滤器，而完全展开的参数方式则提供了更详细和灵活的配置选项。

![image-20240402140812538](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032748.png)

### Shortcut Configuration

![image-20240402141810738](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032529.png)





### Fully Expanded Arguments

![image-20240402141829187](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032042.png)

## 常用的断言API

### 1. After Route Predicate

匹配在指定日期时间之后发生的请求。用于确保只有在某个时间点之后的请求才会被路由。

![image-20240402142156263](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032034.png)

ZonedDateTime对应格式的日期如何获取呢？

```java
import java.time.ZonedDateTime;

public class ZonedDateTimeDemo {
    public static void main(String[] args) {
        ZonedDateTime zonedDateTime = ZonedDateTime.now(); // 默认时区
        System.out.println(zonedDateTime);
    }
}
```



![image-20240402142635806](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032018.png)

yml将时间指定在未来的时间

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: pay_routh1 #pay_routh1                #路由的ID(类似mysql主键ID)，没有固定规则但要求唯一，建议配合服务名
          uri: lb://cloud-payment-service
          predicates:
            - Path=/pay/gateway/get/**              # 断言，路径相匹配的进行路由
            - After=2024-04-02T15:26:21.532342+08:00[Asia/Shanghai]
        - id: pay_routh2 #pay_routh2                #路由的ID(类似mysql主键ID)，没有固定规则但要求唯一，建议配合服务名
          uri: lb://cloud-payment-service
          predicates:
            - Path=/pay/gateway/info/**              # 断言，路径相匹配的进行路由
```

访问http://localhost:9999/pay/gateway/info

![image-20240402143642136](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032450.png)



访问http://localhost/pay/gateway/get/1 此时还没到设定的时间，无法访问

![image-20240402143750237](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032332.png)

### 2. Before Route Predicate

匹配在指定日期时间之前发生的请求。

![image-20240402152252931](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032826.png)

yml修改为

```yaml
            - Before=2024-04-02T15:26:21.532342+08:00[Asia/Shanghai]
```

访问http://localhost/pay/gateway/get/1 此时已经过了设定的时间，无法访问

![image-20240402153206663](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032625.png)



### 3.Between Route Predicate

匹配在指定时间区间内的请求。

![image-20240402153312282](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032155.png)

yml

```yaml
            - Before=2024-04-02T15:36:21.532342+08:00[Asia/Shanghai],2024-04-02T15:26:21.532342+08:00[Asia/Shanghai]
```

访问http://localhost/pay/gateway/get/1 此时时间在设定的时间范围内，可以访问

![image-20240402153429378](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022031406.png)

### 4.Cookie Route Predicate

根据请求中的cookie进行匹配。

Cookie Route Predicate需要两个参数，一个是 Cookie name ,一个是正则表达式。

路由规则会通过获取对应的 Cookie name 值和正则表达式去匹配，如果匹配上就会执行路由，如果没有匹配上则不执行

![image-20240402153551611](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022031737.png)

yml

```yaml
            - Cookie=username,dongguo
```

只有包含指定cookie的请求才能访问，接下来使用三种方式来演示携带Cookie的访问

1.curl命令

![image-20240402154652466](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022031017.png)

2.postman

![image-20240402154858786](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022031640.png)

3.浏览器

![image-20240402155351641](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022031211.png)



### 5.Header Route Predicate

根据请求头中的字段和值进行匹配。

包含两个参数：一个是属性名称和一个正则表达式，这个属性值和正则表达式匹配则执行。

![image-20240402155547268](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022031489.png)

yml

```yaml
            - Header=X-Request-Id, \d+  # 请求头要有X-Request-Id属性并且值为整数的正则表达式
```

postman测试

![image-20240402162023995](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022031328.png)

![image-20240402162041702](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022031154.png)

### 6. Host Route Predicate

Host Route Predicate 接收一组参数，一组匹配的域名列表，这个模板是一个 ant 分隔的模板，用.号作为分隔符。它通过参数中的主机地址作为匹配规则。

![image-20240402162143810](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022031601.png)

yml

```yaml
            - Host=**.dongguo.com
```

postman测试

![image-20240402162727685](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022034326.png)

![image-20240402162838416](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022031647.png)

### 7. Path Route Predicate

根据请求的URI路径进行匹配。

![image-20240402162918436](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022031026.png)

yml

```yaml
            - Path=/pay/gateway/get/**              # 断言，路径相匹配的进行路由
```

这个就不做演示了

### 8. Query Route Predicate

根据请求中的查询参数进行匹配。

支持传入两个参数，一个是属性名，一个为属性值，属性值可以是正则表达式。

![image-20240402163121024](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022031153.png)



yml

```yml
            - Query=username, \d+  # 要有参数名username并且值还要是整数才能路由
```

postman

要有参数名username并且值还要是整数才能路由

![image-20240402163700553](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022031976.png)

![image-20240402163715487](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022031274.png)

### 9. RemoteAddr route predicate

根据发起请求的远程地址进行匹配。

![image-20240402163825354](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022031866.png)

yml

```yaml
            - RemoteAddr=192.168.1.1/24 # 外部访问我的IP限制，最大跨度不超过32，目前是1~24它们是 CIDR 表示法。
```

postman

此时访问就需要使用指定的内网地址

![image-20240402165043858](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022031575.png)

### 10. Method Route Predicate

根据HTTP请求的方法进行匹配，如GET、POST等。

![image-20240402165418327](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022031105.png)

yml

```yml
            - Method=POST
```

postman

![image-20240402165546352](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022031969.png)

## 自定义断言

在 Spring Cloud Gateway 中，您可以创建自定义断言（predicate）来扩展路由匹配的功能。自定义断言允许您根据业务逻辑或特定条件来决定是否应该将请求路由到特定的目标服务。



创建自定义断言时，有两种方式。要么继承AbstractRoutePredicateFactory抽象类，要么直接实现RoutePredicateFactory接口，但是必须以RoutePredicateFactory后缀结尾开头任意取名，

1.如AfterRoutePredicateFactory继承AbstractRoutePredicateFactory抽象类

![image-20240402172833517](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022031379.png)

AfterRoutePredicateFactory继承了 `AbstractRoutePredicateFactory` 并提供了一个配置类 `Config`。`apply` 方法创建了一个 `GatewayPredicate`，它检查请求头中是否存在特定的键和值。

2.直接实现RoutePredicateFactory接口

```java
import org.springframework.cloud.gateway.handler.predicate.GatewayPredicate;  
import org.springframework.cloud.gateway.handler.predicate.RoutePredicateFactory;  
import org.springframework.stereotype.Component;  
import org.springframework.web.server.ServerWebExchange;  
  
import java.util.function.Predicate;  
  
import reactor.core.publisher.Mono;  
  
@Component  
public class CustomHeaderPredicateFactory implements RoutePredicateFactory<CustomHeaderPredicateFactory.Config> {  
  
    @Override  
    public Predicate<ServerWebExchange> apply(Config config) {  
        return exchange -> {  
            String headerValue = exchange.getRequest().getHeaders().getFirst(config.getName());  
            return headerValue != null && headerValue.equals(config.getValue());  
        };  
    }  
  
    @Override  
    public Config newConfig() {  
        return new Config();  
    }  
  
    @Override  
    public String toString() {  
        return "CustomHeader";  
    }  
  
    public static class Config {  
        private String name;  
        private String value;  
  
        // getters and setters  
    }  
}
```

`CustomHeaderPredicateFactory` 实现了 `RoutePredicateFactory` 接口，并定义了如何创建一个新的配置实例（`newConfig` 方法）、应用配置来创建断言（`apply` 方法），以及返回工厂的名称（`toString` 方法）。

### 实现自定义路由断言规则

模拟AfterRoutePredicateFactory类，定义规则：用户类型userType，会员才能够访问，普通用户无法访问

1.新建类名UserTypeRoutePredicateFactory需要以RoutePredicateFactory结尾并继承AbstractRoutePredicateFactory类

2..重写apply方法

3..新建apply方法所需要的静态内部类MyRoutePredicateFactory.Config

4.空参构造方法，内部调用super

```java
import jakarta.validation.constraints.NotEmpty;
import lombok.Getter;
import lombok.Setter;
import org.springframework.cloud.gateway.handler.predicate.AbstractRoutePredicateFactory;
import org.springframework.stereotype.Component;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.server.ServerWebExchange;
import java.util.function.Predicate;

@Component  //标注不可忘
public class UserTypeRoutePredicateFactory extends AbstractRoutePredicateFactory<UserTypeRoutePredicateFactory.Config> {

    /**
     * 空参构造方法，内部调用super
     */
    public UserTypeRoutePredicateFactory() {
        super(UserTypeRoutePredicateFactory.Config.class);
    }

    @Override
    public Predicate<ServerWebExchange> apply(UserTypeRoutePredicateFactory.Config config) {
        return serverWebExchange -> {
            //检查request的参数里面，userType是否为指定的值，符合配置就通过
            String userType = serverWebExchange.getRequest().getQueryParams().getFirst("userType");

            if (userType == null) return false;

            //如果说参数存在，就和config的数据进行比较
            return userType.equals(config.getUserType());
        };
    }

    /**
     * apply方法所需要的静态内部类MyRoutePredicateFactory.Config
     */
    @Validated
    public static class Config {
        @Setter
        @Getter
        @NotEmpty
        private String userType; //用户类型 VIP、Standard  （VIP用户、普通用户）
    }
}
```

### yml

这个配置怎么来的呢？UserType对应的是UserTypeRoutePredicateFactory的RoutePredicateFactory前面的部分，VIP对应的是用户类型

```yml
            - UserType=VIP
```

#### 测试

启动就报错

```shell
reactor.core.Exceptions$ErrorCallbackNotImplemented: org.springframework.boot.context.properties.bind.BindException: Failed to bind properties under '' to com.dongguo.cloud.GateWay.UserTypeRoutePredicateFactory$Config
Caused by: org.springframework.boot.context.properties.bind.BindException: Failed to bind properties under '' to com.dongguo.cloud.GateWay.UserTypeRoutePredicateFactory$Config
	at 
	......
		... 24 common frames omitted
Caused by: org.springframework.boot.context.properties.bind.validation.BindValidationException: Binding validation errors on 
   - Field error in object '' on field 'userType': rejected value [null]; codes [NotEmpty.userType,NotEmpty.java.lang.String,NotEmpty]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [.userType,userType]; arguments []; default message [userType]]; default message [不能为空]
	at 
	......
	... 59 common frames omitted
```

这是因为我们在yml中配置的断言是Shortcut Configuration，但是我们并没有实现Shortcut Configuration的代码

这里可以使用Fully Expanded Arguments

```yml
            - name: UserType
              args:
                userType: VIP
```

name:UserType对应UserTypeRoutePredicateFactory的RoutePredicateFactory前面的部分

userType:VIP 对应用户类型：VIP

#### 再次测试

启动GateWay，可以看到我们的自定义断言UserType

![image-20240402203333059](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022034423.png)

http://localhost:9999/pay/gateway/get/1?userType=VIP

![image-20240402202544781](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022030518.png)

http://localhost:9999/pay/gateway/get/1?userType=Standard

![image-20240402202846050](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022030878.png)

这样自定义规则已经通过，如果想要使用Shortcut Configuration，UserTypeRoutePredicateFactory就要实现Shortcut Configuration的代码

```java
    @Override
    public List<String> shortcutFieldOrder() {
        return Collections.singletonList("userType");
    }
```

这样yml配置修改回

```yml
            - UserType=VIP
```

#### 测试

http://localhost:9999/pay/gateway/get/1?userType=VIP

![image-20240402202938899](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022030311.png)

http://localhost:9999/pay/gateway/get/1?userType=Standard

![image-20240402202907616](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022030450.png)

# Filter过滤

和SpringMVC里面的的拦截器Interceptor,Servlet的过滤器一样。

在Spring Cloud Gateway中，过滤器（Filter）是处理请求和响应的组件，它们在请求被路由到实际服务之前或之后执行某些操作。Spring Cloud Gateway的过滤器允许你在请求生命周期的不同阶段应用逻辑，比如添加请求头、验证请求参数、记录日志等。

过滤器分为两种类型：

1. **全局过滤器（Global Filters）**：这些过滤器作用于所有路由。它们通常用于跨多个路由的通用逻辑，比如日志记录或认证，不需要在配置文件中配置。
2. **路由过滤器（Gateway Filters）**：这些过滤器只应用于特定路由。你可以为每个路由定义一组特定的过滤器，以便执行与该路由相关的特定逻辑，也可以称为网关过滤器。

在Spring Cloud Gateway中，过滤器可以是内置的（预先定义好的），也可以是自定义的。自定义过滤器通常是通过实现`GlobalFilter`接口或`GatewayFilter`接口来完成的。



## 作用

请求鉴权

异常处理

接口调用时长统计

.....

GateWay内置的过滤器
