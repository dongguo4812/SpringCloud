# Route实现动态路由

在上一节中，我们路由映射的URI配置是写死的

![image-20240402104425026](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032003.png)

GateWay提供了动态获取服务URI的功能，使得路由不依赖于具体的IP和端口。这一功能通常借助于服务注册中心来实现。Gateway可以从注册中心获取微服务的可用列表，以注册中心上微服务名为路径创建动态路由进行转发，从而实现动态路由的功能

对于使用`lb://`（表示负载均衡）前缀来指定服务URI，如`uri: lb://cloud-payment-service`

![image-20240402110606650](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032797.png)

## cloud-gateway9999 

yml：

将uri: http://localhost:8001 替换为uri: lb://cloud-payment-service

![image-20240402114250322](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032145.png)

## 测试

**重启网关9527,80/8001保持不变**，访问http://localhost/feign/pay/gateway/get/1

![image-20240402111513457](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032723.png)

如果将8001微服务yml文件端口修改为8007

![image-20240402111628581](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032696.png)

等待cloud-payment-service服务注册到consul中，访问http://localhost/feign/pay/gateway/get/1

![image-20240402111657330](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032130.png)

端口名改为8007，依然能够成功访问



这里需要强调一下，`uri: lb://cloud-payment-service` 指Gateway 使用客户端负载均衡来解析服务名 `cloud-payment-service` 到具体的服务实例。

`lb://` 前缀是 Spring Cloud 为客户端负载均衡提供的一个特殊协议。当 Spring Cloud Gateway 遇到这样的 URI 时，它会查找配置的负载均衡器（可能是 `spring-cloud-loadbalancer`，也可能是其他兼容的负载均衡库），并使用这个负载均衡器来解析服务名到具体的服务实例。

![image-20240402134147510](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032885.png)

默认情况下`discovery.locator.enabled: false`  是禁用了 Spring Cloud Gateway 内置的服务发现定位器功能，这意味着 Gateway 不会尝试从服务注册中心（如 Eureka、Consul 等）自动获取服务实例信息来创建路由。但是，这并不影响 Gateway 使用其他已经配置的负载均衡机制来解析服务名。

# Predicate断言

![image-20240402134920676](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032514.png)

Spring Cloud Gateway作为Spring WebFlux HandlerMapping基础设施的一部分来匹配路由。Spring Cloud Gateway包含许多内置的路由断言工厂。所有这些断言都是基于HTTP请求的不同属性进行匹配的。你可以将多个路由断言工厂通过逻辑与语句组合在一起。



在启动微服务gateway9999看到IDEA后台的输出，Spring Cloud Gateway 创建 Route 对象时， 使用 RoutePredicateFactory 创建 Predicate 对象，Predicate 对象可以赋值给 Route。 Spring Cloud Gateway 包含许多内置的Route Predicate Factories。

![image-20240402135433742](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032587.png)Gateway 服务在启动时，会加载和注册一系列的路由断言工厂（RoutePredicateFactory）。这些断言工厂用于定义路由规则，根据HTTP请求的特定属性（如请求头、请求方法、路径等)来决定是否应该将请求路由到特定的服务或端点。

RoutePredicateFactory：

下面会挨个介绍

![image-20240402145804644](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022034800.png)



## Route Predicate

在Spring Cloud Gateway中，配置断言（predicates）和过滤器（filters）有两种主要方式：使用快捷方式（shortcuts）和完全展开的参数方式（fully expanded arguments）。快捷方式提供了一种简洁的方法来快速配置常见的断言和过滤器，而完全展开的参数方式则提供了更详细和灵活的配置选项。

![image-20240402140812538](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032748.png)

### Shortcut Configuration

![image-20240402141810738](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032529.png)





### Fully Expanded Arguments

![image-20240402141829187](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032042.png)

## 常用的断言API

### 1. After Route Predicate

匹配在指定日期时间之后发生的请求。用于确保只有在某个时间点之后的请求才会被路由。

![image-20240402142156263](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032034.png)

ZonedDateTime对应格式的日期如何获取呢？

```java
import java.time.ZonedDateTime;

public class ZonedDateTimeDemo {
    public static void main(String[] args) {
        ZonedDateTime zonedDateTime = ZonedDateTime.now(); // 默认时区
        System.out.println(zonedDateTime);
    }
}
```



![image-20240402142635806](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032018.png)

yml将时间指定在未来的时间

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: pay_routh1 #pay_routh1                #路由的ID(类似mysql主键ID)，没有固定规则但要求唯一，建议配合服务名
          uri: lb://cloud-payment-service
          predicates:
            - Path=/pay/gateway/get/**              # 断言，路径相匹配的进行路由
            - After=2024-04-02T15:26:21.532342+08:00[Asia/Shanghai]
        - id: pay_routh2 #pay_routh2                #路由的ID(类似mysql主键ID)，没有固定规则但要求唯一，建议配合服务名
          uri: lb://cloud-payment-service
          predicates:
            - Path=/pay/gateway/info/**              # 断言，路径相匹配的进行路由
```

访问http://localhost:9999/pay/gateway/info

![image-20240402143642136](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032450.png)



访问http://localhost/pay/gateway/get/1 此时还没到设定的时间，无法访问

![image-20240402143750237](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032332.png)

### 2. Before Route Predicate

匹配在指定日期时间之前发生的请求。

![image-20240402152252931](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032826.png)

yml修改为

```yaml
            - Before=2024-04-02T15:26:21.532342+08:00[Asia/Shanghai]
```

访问http://localhost/pay/gateway/get/1 此时已经过了设定的时间，无法访问

![image-20240402153206663](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032625.png)



### 3.Between Route Predicate

匹配在指定时间区间内的请求。

![image-20240402153312282](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022032155.png)

yml

```yaml
            - Before=2024-04-02T15:36:21.532342+08:00[Asia/Shanghai],2024-04-02T15:26:21.532342+08:00[Asia/Shanghai]
```

访问http://localhost/pay/gateway/get/1 此时时间在设定的时间范围内，可以访问

![image-20240402153429378](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022031406.png)

### 4.Cookie Route Predicate

根据请求中的cookie进行匹配。

Cookie Route Predicate需要两个参数，一个是 Cookie name ,一个是正则表达式。

路由规则会通过获取对应的 Cookie name 值和正则表达式去匹配，如果匹配上就会执行路由，如果没有匹配上则不执行

![image-20240402153551611](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022031737.png)

yml

```yaml
            - Cookie=username,dongguo
```

只有包含指定cookie的请求才能访问，接下来使用三种方式来演示携带Cookie的访问

1.curl命令

![image-20240402154652466](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022031017.png)

2.postman

![image-20240402154858786](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031315730.png)

3.浏览器

![image-20240402155351641](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031315938.png)



### 5.Header Route Predicate

根据请求头中的字段和值进行匹配。

包含两个参数：一个是属性名称和一个正则表达式，这个属性值和正则表达式匹配则执行。

![image-20240402155547268](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031315140.png)

yml

```yaml
            - Header=X-Request-Id, \d+  # 请求头要有X-Request-Id属性并且值为整数的正则表达式
```

postman测试

![image-20240402162023995](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031315800.png)

![image-20240402162041702](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031315012.png)

### 6. Host Route Predicate

Host Route Predicate 接收一组参数，一组匹配的域名列表，这个模板是一个 ant 分隔的模板，用.号作为分隔符。它通过参数中的主机地址作为匹配规则。

![image-20240402162143810](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031315144.png)

yml

```yaml
            - Host=**.dongguo.com
```

postman测试

![image-20240402162727685](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031315184.png)

![image-20240402162838416](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031315171.png)

### 7. Path Route Predicate

根据请求的URI路径进行匹配。

![image-20240402162918436](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031315833.png)

yml

```yaml
            - Path=/pay/gateway/get/**              # 断言，路径相匹配的进行路由
```

这个就不做演示了

### 8. Query Route Predicate

根据请求中的查询参数进行匹配。

支持传入两个参数，一个是属性名，一个为属性值，属性值可以是正则表达式。

![image-20240402163121024](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031315602.png)



yml

```yml
            - Query=username, \d+  # 要有参数名username并且值还要是整数才能路由
```

postman

要有参数名username并且值还要是整数才能路由

![image-20240402163700553](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031314143.png)

![image-20240402163715487](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031314366.png)

### 9. RemoteAddr route predicate

根据发起请求的远程地址进行匹配。

![image-20240402163825354](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031314459.png)

yml

```yaml
            - RemoteAddr=192.168.1.1/24 # 外部访问我的IP限制，最大跨度不超过32，目前是1~24它们是 CIDR 表示法。
```

postman

此时访问就需要使用指定的内网地址

![image-20240402165043858](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031314352.png)

### 10. Method Route Predicate

根据HTTP请求的方法进行匹配，如GET、POST等。

![image-20240402165418327](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031314697.png)

yml

```yml
            - Method=POST
```

postman

![image-20240402165546352](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031314801.png)

## 自定义断言

在 Spring Cloud Gateway 中，您可以创建自定义断言（predicate）来扩展路由匹配的功能。自定义断言允许您根据业务逻辑或特定条件来决定是否应该将请求路由到特定的目标服务。



创建自定义断言时，有两种方式。要么继承AbstractRoutePredicateFactory抽象类，要么直接实现RoutePredicateFactory接口，但是必须以RoutePredicateFactory后缀结尾开头任意取名，

1.如AfterRoutePredicateFactory继承AbstractRoutePredicateFactory抽象类

![image-20240402172833517](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031314812.png)

AfterRoutePredicateFactory继承了 `AbstractRoutePredicateFactory` 并提供了一个配置类 `Config`。`apply` 方法创建了一个 `GatewayPredicate`，它检查请求头中是否存在特定的键和值。

2.直接实现RoutePredicateFactory接口

```java
import org.springframework.cloud.gateway.handler.predicate.GatewayPredicate;  
import org.springframework.cloud.gateway.handler.predicate.RoutePredicateFactory;  
import org.springframework.stereotype.Component;  
import org.springframework.web.server.ServerWebExchange;  
  
import java.util.function.Predicate;  
  
import reactor.core.publisher.Mono;  
  
@Component  
public class CustomHeaderPredicateFactory implements RoutePredicateFactory<CustomHeaderPredicateFactory.Config> {  
  
    @Override  
    public Predicate<ServerWebExchange> apply(Config config) {  
        return exchange -> {  
            String headerValue = exchange.getRequest().getHeaders().getFirst(config.getName());  
            return headerValue != null && headerValue.equals(config.getValue());  
        };  
    }  
  
    @Override  
    public Config newConfig() {  
        return new Config();  
    }  
  
    @Override  
    public String toString() {  
        return "CustomHeader";  
    }  
  
    public static class Config {  
        private String name;  
        private String value;  
  
        // getters and setters  
    }  
}
```

`CustomHeaderPredicateFactory` 实现了 `RoutePredicateFactory` 接口，并定义了如何创建一个新的配置实例（`newConfig` 方法）、应用配置来创建断言（`apply` 方法），以及返回工厂的名称（`toString` 方法）。

### 实现自定义路由断言规则

模拟AfterRoutePredicateFactory类，定义规则：用户类型userType，会员才能够访问，普通用户无法访问

1.新建类名UserTypeRoutePredicateFactory需要以RoutePredicateFactory结尾并继承AbstractRoutePredicateFactory类

2..重写apply方法

3..新建apply方法所需要的静态内部类MyRoutePredicateFactory.Config

4.空参构造方法，内部调用super

```java
import jakarta.validation.constraints.NotEmpty;
import lombok.Getter;
import lombok.Setter;
import org.springframework.cloud.gateway.handler.predicate.AbstractRoutePredicateFactory;
import org.springframework.stereotype.Component;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.server.ServerWebExchange;
import java.util.function.Predicate;

@Component  //标注不可忘
public class UserTypeRoutePredicateFactory extends AbstractRoutePredicateFactory<UserTypeRoutePredicateFactory.Config> {

    /**
     * 空参构造方法，内部调用super
     */
    public UserTypeRoutePredicateFactory() {
        super(UserTypeRoutePredicateFactory.Config.class);
    }

    @Override
    public Predicate<ServerWebExchange> apply(UserTypeRoutePredicateFactory.Config config) {
        return serverWebExchange -> {
            //检查request的参数里面，userType是否为指定的值，符合配置就通过
            String userType = serverWebExchange.getRequest().getQueryParams().getFirst("userType");

            if (userType == null) return false;

            //如果说参数存在，就和config的数据进行比较
            return userType.equals(config.getUserType());
        };
    }

    /**
     * apply方法所需要的静态内部类MyRoutePredicateFactory.Config
     */
    @Validated
    public static class Config {
        @Setter
        @Getter
        @NotEmpty
        private String userType; //用户类型 VIP、Standard  （VIP用户、普通用户）
    }
}
```

### yml

这个配置怎么来的呢？UserType对应的是UserTypeRoutePredicateFactory的RoutePredicateFactory前面的部分，VIP对应的是用户类型

```yml
            - UserType=VIP
```

#### 测试

启动就报错

```shell
reactor.core.Exceptions$ErrorCallbackNotImplemented: org.springframework.boot.context.properties.bind.BindException: Failed to bind properties under '' to com.dongguo.cloud.GateWay.UserTypeRoutePredicateFactory$Config
Caused by: org.springframework.boot.context.properties.bind.BindException: Failed to bind properties under '' to com.dongguo.cloud.GateWay.UserTypeRoutePredicateFactory$Config
	at 
	......
		... 24 common frames omitted
Caused by: org.springframework.boot.context.properties.bind.validation.BindValidationException: Binding validation errors on 
   - Field error in object '' on field 'userType': rejected value [null]; codes [NotEmpty.userType,NotEmpty.java.lang.String,NotEmpty]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [.userType,userType]; arguments []; default message [userType]]; default message [不能为空]
	at 
	......
	... 59 common frames omitted
```

这是因为我们在yml中配置的断言是Shortcut Configuration，但是我们并没有实现Shortcut Configuration的代码

这里可以使用Fully Expanded Arguments

```yml
            - name: UserType
              args:
                userType: VIP
```

name:UserType对应UserTypeRoutePredicateFactory的RoutePredicateFactory前面的部分

userType:VIP 对应用户类型：VIP

#### 再次测试

启动GateWay，可以看到我们的自定义断言UserType

![image-20240402203333059](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031314130.png)

http://localhost:9999/pay/gateway/get/1?userType=VIP

![image-20240402202544781](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031314006.png)

http://localhost:9999/pay/gateway/get/1?userType=Standard

![image-20240402202846050](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022030878.png)

这样自定义规则已经通过，如果想要使用Shortcut Configuration，UserTypeRoutePredicateFactory就要实现Shortcut Configuration的代码

```java
    @Override
    public List<String> shortcutFieldOrder() {
        return Collections.singletonList("userType");
    }
```

这样yml配置修改回

```yml
            - UserType=VIP
```

#### 测试

http://localhost:9999/pay/gateway/get/1?userType=VIP

![image-20240402202938899](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031314009.png)

http://localhost:9999/pay/gateway/get/1?userType=Standard

![image-20240402202907616](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404022030450.png)

# Filter过滤

和SpringMVC里面的的拦截器Interceptor,Servlet的过滤器一样。

在Spring Cloud Gateway中，过滤器（Filter）是处理请求和响应的组件，它们在请求被路由到实际服务之前或之后执行某些操作。Spring Cloud Gateway的过滤器允许你在请求生命周期的不同阶段应用逻辑，比如添加请求头、验证请求参数、记录日志等。

过滤器分为两种类型：

1. **全局过滤器（Global Filters）**：这些过滤器作用于所有路由。它们通常用于跨多个路由的通用逻辑，比如日志记录或认证，Global Filters是默认已经存在的，不需要在配置文件中配置。

   ![image-20240403073029229](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031314324.png)

2. **路由过滤器（Gateway Filters）**：这些过滤器只应用于特定路由。你可以为每个路由定义一组特定的过滤器，以便执行与该路由相关的特定逻辑，也可以称为网关过滤器。

   ![image-20240403073232866](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031314540.png)

在Spring Cloud Gateway中，过滤器可以是内置的（预先定义好的），也可以是自定义的。自定义过滤器通常是通过实现`GlobalFilter`接口或`GatewayFilter`接口来完成的。



## 作用

请求鉴权

异常处理

接口调用时长统计

.....

## 全局过滤器（Global Filters）

全局过滤器默认是会被加载和生效的，因为它们的目的是处理所有通过网关的请求和响应，不需要针对特定的路由进行配置。在Spring Cloud Gateway中，全局过滤器会在请求被路由到目标服务之前或之后执行一些操作，例如记录日志、身份验证、请求和响应的修改等。                                                                                                                                                                                                                                                                                                                                                                                                                                 

![image-20240403074215010](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031314100.png)

- Combined Global Filter和GatewayFilter Ordering涉及全局过滤器的组合和排序，这对于确保过滤器按照正确的顺序执行至关重要。正确的排序可以确保请求和响应在处理过程中得到正确的处理。

- Gateway Metrics Filter用于收集并报告关于网关性能的指标，这对于监控和优化网关性能非常有帮助。

- Local Response Cache Filter提供了本地响应缓存功能，可以缓存某些请求的响应，从而提高性能并减少下游服务的负载。

- Forward Routing Filter会查看请求的特定属性，并根据该属性来决定是否使用Spring的DispatcherHandler来处理请求。这在需要将请求转发到本地端点时非常有用。

- Netty Routing Filter、Netty Write Response Filter和ReactiveLoadBalancerClientFilter与底层通信框架Netty和负载均衡有关，它们确保了请求能够正确地路由到目标服务，并处理响应的写回。

- RouteToRequestUrl Filter和Websocket Routing Filter则分别涉及将请求路由到特定的URL和处理Websocket请求。



## 路由过滤器（Gateway Filters）

路由过滤器（Gateway Filters）是专门针对某个特定路由定义的过滤器，它们只对匹配该路由的请求生效。因此，路由过滤器需要显式地配置到路由定义中才会生效。这些配置通常在路由配置文件中进行，通过定义一系列的过滤器名称和参数来实现。

### 1.请求头(RequestHeader)相关组

#### AddRequestHeader GatewayFilter Factory

用于向传入的HTTP请求中添加自定义的请求头。在Spring Cloud Gateway中，你可以使用AddRequestHeader GatewayFilter Factory来动态地给请求添加或修改请求头信息。

使用AddRequestHeader GatewayFilter Factory时，你需要指定两个参数：请求头的名称（name）和对应的值（value）。这些参数可以在路由配置中定义，以便对匹配该路由的请求应用此过滤器。

![image-20240403081819214](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031314220.png)

##### cloud-provider-payment8001

PayGateWayController新增方法

```java
@GetMapping(value = "/pay/gateway/filter")
public Result<String> getGatewayFilter(HttpServletRequest request) {
    String result = "";
    Enumeration<String> headers = request.getHeaderNames();
    while (headers.hasMoreElements()) {
        String headName = headers.nextElement();
        String headValue = request.getHeader(headName);
        System.out.println("请求头名: " + headName + "\t\t\t" + "请求头值: " + headValue);
        if (headName.equalsIgnoreCase("X-Request-name1")
                || headName.equalsIgnoreCase("X-Request-name2")) {
            result = result + headName + "\t " + headValue + " ";
        }
    }
    return Result.success("GatewayFilter 过滤器： " + result + " \t " + DateUtil.now());
}
```



##### cloud-gateway9999 

给请求添加了两个自定义的头信息。第一个头信息名为`X-Request-name1`，值为`zhangsan`；第二个头信息名为`X-Request-name2`，值为`lisi`。

```yaml
        - id: pay_routh3
          uri: lb://cloud-payment-service                #匹配后提供服务的路由地址
          predicates:
            - Path=/pay/gateway/filter/**              # 断言，路径相匹配的进行路由
          filters:
            - AddRequestHeader=X-Request-name1,zhangsan  # 请求头kv，若一头含有多参则重写一行设置
            - AddRequestHeader=X-Request-name2,lisi
```

##### 测试

http://localhost:9999/pay/gateway/filter

![image-20240403091140864](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031314181.png)

控制台打印出所有的请求头信息，我们自定义的头信息存在这次请求中

![image-20240403091444467](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031314085.png)

#### RemoveRequestHeader GatewayFilter Factory

从请求中移除指定的 HTTP 头部信息。

![image-20240403093851082](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031314302.png)

删除请求头sec-fetch-site

![image-20240403094128041](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031314032.png)

##### yml

```yaml
            - RemoveRequestHeader=sec-fetch-site      # 删除请求头sec-fetch-site
```

##### 测试

http://localhost:9999/pay/gateway/filter

请求头中sec-fetch-site已经不存在

![image-20240403094406617](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031314213.png)

#### SetRequestHeader GatewayFilter Factory

设置或修改请求的 HTTP 头部信息。这个过滤器工厂允许你添加新的头部，或者覆盖已存在的头部。

![image-20240403094524736](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031314947.png)

修改sec-fetch-mode

![image-20240403094719675](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031314223.png)

##### yml

```yml
            - SetRequestHeader=sec-fetch-mode,cors  # 将请求头sec-fetch-mode对应的值修改为cors
```

##### 测试

http://localhost:9999/pay/gateway/filter

![image-20240403095031006](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031314254.png)

### 2.请求参数(RequestParameter)相关组

#### AddRequestParameter GatewayFilter Factory

向请求中添加或修改请求参数。

![image-20240403095127527](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031314710.png)

##### cloud-gateway9999 

yml

```yaml
            - AddRequestParameter=name,dongguo # 新增请求参数Parameter：k ，v
```

PayGateWayController

```java
@GetMapping(value = "/pay/gateway/filter")
public Result<String> getGatewayFilter(HttpServletRequest request) {
    String result = "";
    Enumeration<String> headers = request.getHeaderNames();
    while (headers.hasMoreElements()) {
        String headName = headers.nextElement();
        String headValue = request.getHeader(headName);
        System.out.println("请求头名: " + headName + "\t\t\t" + "请求头值: " + headValue);
        if (headName.equalsIgnoreCase("X-Request-name1")
                || headName.equalsIgnoreCase("X-Request-name2")) {
            result = result + headName + "\t " + headValue + " ";
        }
    }
    System.out.println("=============================================");
    String name = request.getParameter("name");
    System.out.println("request Parameter name: "+name);

    String age = request.getParameter("age");
    System.out.println("request Parameter age: "+age);
    System.out.println("=============================================");
    return Result.success("GatewayFilter 过滤器： " + result + " \t " + DateUtil.now());
}
```

##### cloud-provider-payment8001

获取请求参数

```java
    @GetMapping(value = "/pay/gateway/filter")
    public Result<String> getGatewayFilter(HttpServletRequest request) {
        String result = "";
        Enumeration<String> headers = request.getHeaderNames();
        while (headers.hasMoreElements()) {
            String headName = headers.nextElement();
            String headValue = request.getHeader(headName);
            System.out.println("请求头名: " + headName + "\t\t\t" + "请求头值: " + headValue);
            if (headName.equalsIgnoreCase("X-Request-name1")
                    || headName.equalsIgnoreCase("X-Request-name2")) {
                result = result + headName + "\t " + headValue + " ";
            }
        }
        System.out.println("=============================================");
        String name = request.getParameter("name");
        System.out.println("request Parameter name: "+name);

        String age = request.getParameter("age");
        System.out.println("request Parameter age: "+age);
        System.out.println("=============================================");
        return Result.success("GatewayFilter 过滤器： " + result + " \t " + DateUtil.now());
    }
```



##### 测试

http://localhost:9999/pay/gateway/filter

![image-20240403100824015](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031314229.png)

### RemoveRequestParameter GatewayFilter Factory

从请求中移除指定的请求参数。

![image-20240403100904109](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031314733.png)

##### yml

```yaml
            - RemoveRequestParameter=age
```

##### 测试

http://localhost:9999/pay/gateway/filter?age=18

![image-20240403101222142](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031313740.png)



![image-20240403101236756](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031313150.png)

### 3.响应头(ResponseHeader)相关组

这是http://localhost:9999/pay/gateway/filter请求的响应头

![image-20240403101434714](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031313175.png)

#### AddResponseHeader GatewayFilter Factory

向响应中添加或修改 HTTP 头部信息

![image-20240403101557989](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031313190.png)

##### yml

```yml
            - AddResponseHeader=X-Response-name1, zhangsan # 新增请求参数X-Response-name1
```

##### 测试

http://localhost:9999/pay/gateway/filter

![image-20240403102710841](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031313332.png)

### RemoveResponseHeader GatewayFilter Factory

从 HTTP 响应中移除指定的头部信息

![image-20240403102810438](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031313565.png)

##### yml

```yaml
            - RemoveResponseHeader=Content-Type # 将默认自带Content-Type回应属性删除
```

##### 测试

![image-20240403103022270](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031313774.png)

### SetResponseHeader GatewayFilter Factory

用于设置或覆盖通过网关的 HTTP 响应中的特定头部信息

![image-20240403103055964](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031313333.png)

##### yml

```yml
            - SetResponseHeader=Date,2099-11-11 # 设置回应头Date值为2099-11-11
```

##### 测试

![image-20240403103321343](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031313479.png)

### 4.前缀和路径相关组

#### PrefixPath GatewayFilter Factory

为请求的URI添加指定的前缀。

![image-20240403104030903](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031313727.png)

##### yml

```yml
        - id: pay_routh3
          uri: lb://cloud-payment-service                #匹配后提供服务的路由地址
          predicates:
            - Path=/gateway/filter/**              # 断言，路径相匹配的进行路由
          filters:
            - PrefixPath=/pay # http://localhost:9527/pay/gateway/filter
```



| 之前完整正确地址： | http://localhost:9999/pay/gateway/filter                     |
| ------------------ | ------------------------------------------------------------ |
| 现在完整组合地址： | PrefixPath + Path                                            |
| 实际调用地址：     | http://localhost:9999/gateway/filter**相当于说前缀被过滤器统一管理了。** |

##### 测试

只需要访问http://localhost:9999/gateway/filter即可

![image-20240403104641512](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031313702.png)

#### SetPath GatewayFilter Factory

设置或修改通过网关的请求的 URI 路径。

![image-20240403104723377](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031313905.png)

##### yml

```yaml
        - id: pay_routh3
          uri: lb://cloud-payment-service                #匹配后提供服务的路由地址
          predicates:
            - Path=/XYZ/abc/{segment}           # 断言，为配合SetPath测试，{segment}的内容最后被SetPath取代

          filters:
            - SetPath=/pay/gateway/{segment}  # {segment}表示占位符，你写abc也行但要上下一致
```

如果有一个请求的路径是 `/XYZ/abc/filter`，那么经过 `SetPath` 过滤器处理后，该请求的路径会被修改为 `/pay/gateway/filter`，然后转发到 `lb://cloud-payment-service`。

##### 测试

![image-20240403105615065](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031313213.png)

#### RedirectTo GatewayFilter Factory

将请求重定向到另一个URL。

![image-20240403105717307](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031313752.png)

##### yml

```yaml
        - id: pay_routh3
          uri: lb://cloud-payment-service                #匹配后提供服务的路由地址
          predicates:
            - Path=/pay/gateway/filter/**              # 断言，路径相匹配的进行路由
          filters:
            - RedirectTo=302, http://www.baidu.com/ # 访问http://localhost:9999/pay/gateway/filter跳转到http://www.baidu.com/
```

##### 测试

访问http://localhost:9999/pay/gateway/filter跳转到http://www.baidu.com/

![image-20240403110000066](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031313470.png)

### 5.其它

#### Default Filters

Default Filters，即默认过滤器，是 Spring Cloud Gateway 预先定义并内置的一些常用过滤器，无需额外配置即可使用。这些默认过滤器提供了一些常见的请求处理逻辑，如添加请求头、修改请求路径、重定向等。

以下是一些常用的 Default Filters 及其功能简述：

1. **AddRequestHeader**：为请求添加指定的头部信息。
2. **AddRequestParameter**：为请求添加指定的参数。
3. **AddResponseHeader**：为响应添加指定的头部信息。
4. **StripPrefix**：从请求的路径中去除指定数量的路径段前缀。
5. **RewritePath**：重写请求的路径。
6. **RedirectTo**：将请求重定向到另一个URL。

在 Spring Cloud Gateway 中，`default-filters` 属性允许配置一组过滤器，这些过滤器会自动应用到所有的路由上，无需在每个路由定义中单独配置。因此，这种行为确实类似于全局过滤器的概念。

![image-20240403110101296](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031318866.png)

## 自定义过滤器

### 自定义全局过滤器

在提供的示例中，创建了一个自定义的全局过滤器 `CustomGlobalFilter`，它实现了 `GlobalFilter` 和 `Ordered` 接口。这个过滤器的作用是简单地记录一条日志信息，并通过 `GatewayFilterChain` 将请求传递给下一个过滤器。

在 `CustomGlobalFilter` 类中，`getOrder()` 方法返回 `-1`，这意味着该全局过滤器在所有其他未指定排序值或排序值大于 `-1` 的全局过滤器和路由过滤器之前执行。由于排序值越小，过滤器越先执行，因此 `CustomGlobalFilter` 将是“pre”阶段的第一个过滤器，并在“post”阶段的所有过滤器之后执行。

![image-20240403111142118](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031313469.png)

通过自定义全局过滤器统计接口调用耗时情况

#### 新建类LoggingGlobalFilter并实现GlobalFilter,Ordered两个接口

这个过滤器主要用来记录请求访问接口的开始时间，并在请求处理完成后记录访问时长以及相关的请求信息。

```java
import lombok.extern.slf4j.Slf4j;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.Ordered;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

@Component //不要忘记
@Slf4j
public class LoggingGlobalFilter implements GlobalFilter, Ordered {
    private static final String BEGIN_VISIT_TIME = "begin_visit_time";//开始访问时间

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        //先记录下访问接口的开始时间
        exchange.getAttributes().put(BEGIN_VISIT_TIME, System.currentTimeMillis());

        return chain.filter(exchange).then(Mono.fromRunnable(() -> {
            Long beginVisitTime = exchange.getAttribute(BEGIN_VISIT_TIME);
            if (beginVisitTime != null) {
                log.info("访问接口主机: " + exchange.getRequest().getURI().getHost());
                log.info("访问接口端口: " + exchange.getRequest().getURI().getPort());
                log.info("访问接口URL: " + exchange.getRequest().getURI().getPath());
                log.info("访问接口URL参数: " + exchange.getRequest().getURI().getRawQuery());
                log.info("访问接口时长: " + (System.currentTimeMillis() - beginVisitTime) + "ms");
                log.info("###################################################");
            }
        }));
    }

    @Override
    public int getOrder() {
        return 0;
    }
}
 
```

#### yml

恢复原状

```yaml
server:
  port: 9999

spring:
  application:
    name: cloud-gateway #以微服务注册进consul或nacos服务列表内
  cloud:
    consul: #配置consul地址
      host: localhost
      port: 8500
      discovery:
        prefer-ip-address: true
        service-name: ${spring.application.name}
    gateway:
      routes:
        - id: pay_routh1 #pay_routh1                #路由的ID(类似mysql主键ID)，没有固定规则但要求唯一，建议配合服务名
          uri: lb://cloud-payment-service
          predicates:
            - Path=/pay/gateway/get/**              # 断言，路径相匹配的进行路由
        - id: pay_routh2 #pay_routh2                #路由的ID(类似mysql主键ID)，没有固定规则但要求唯一，建议配合服务名
          uri: lb://cloud-payment-service
          predicates:
            - Path=/pay/gateway/info/**              # 断言，路径相匹配的进行路由
        - id: pay_routh3
          uri: lb://cloud-payment-service                #匹配后提供服务的路由地址
          predicates:
            - Path=/pay/gateway/filter/**              # 断言，路径相匹配的进行路由
```

#### 测试

![image-20240403113134873](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031313421.png)

### 自定义路由过滤器

自定义的路由过滤器，实现`GatewayFilter`接口或者扩展`AbstractGatewayFilterFactory`类。

找一个实现AbstractGatewayFilterFactory类的过滤器，如RemoveRequestHeaderGatewayFilterFactory，模仿实现

```java
public class RemoveRequestHeaderGatewayFilterFactory
       extends AbstractGatewayFilterFactory<AbstractGatewayFilterFactory.NameConfig> {

    public RemoveRequestHeaderGatewayFilterFactory() {
       super(NameConfig.class);
    }

    @Override
    public List<String> shortcutFieldOrder() {
       return Arrays.asList(NAME_KEY);
    }

    @Override
    public GatewayFilter apply(NameConfig config) {
       return new GatewayFilter() {
          @Override
          public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
             ServerHttpRequest request = exchange.getRequest().mutate()
                   .headers(httpHeaders -> httpHeaders.remove(config.getName())).build();

             return chain.filter(exchange.mutate().request(request).build());
          }

          @Override
          public String toString() {
             return filterToStringCreator(RemoveRequestHeaderGatewayFilterFactory.this)
                   .append("name", config.getName()).toString();
          }
       };
    }

}
```

1.新建类名StatusGatewayFilterFactory需要以GatewayFilterFactory结尾并继承AbstractGatewayFilterFactory类

2.新建StatusGatewayFilterFactory.Config内部类

3.重写apply方法

4.重写shortcut FieldOrder

5.空参构造方法，内部调用super

#### StatusGatewayFilterFactory

根据请求中的参数来决定是否允许请求继续通过网关，或者返回一个BAD_REQUEST状态码（400）。

```java
import lombok.Getter;
import lombok.Setter;
import org.springframework.cloud.gateway.filter.GatewayFilter;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

import java.util.Arrays;
import java.util.List;

@Component
public class StatusGatewayFilterFactory extends AbstractGatewayFilterFactory<StatusGatewayFilterFactory.Config> {
    public StatusGatewayFilterFactory() {
        super(StatusGatewayFilterFactory.Config.class);
    }


    @Override
    public GatewayFilter apply(StatusGatewayFilterFactory.Config config) {
        return (exchange, chain) -> {
            ServerHttpRequest request = exchange.getRequest();
            System.out.println("进入了自定义网关过滤器StatusGatewayFilterFactory，status：" + config.getStatus());
            //请求中的查询参数必须带有userStatus才允许访问
            if (request.getQueryParams().containsKey("userStatus")) {
                return chain.filter(exchange);
            } else {
                exchange.getResponse().setStatusCode(HttpStatus.BAD_REQUEST);
                return exchange.getResponse().setComplete();
            }
        };
    }

    @Override
    public List<String> shortcutFieldOrder() {
        return Arrays.asList("status");
    }

    public static class Config {
        @Getter
        @Setter
        private String status;//设定一个状态值/标志位，它等于多少，匹配和才可以访问
    }
}
```

#### yml

```
    gateway:
      routes:
        - id: pay_routh1 #pay_routh1                #路由的ID(类似mysql主键ID)，没有固定规则但要求唯一，建议配合服务名
          uri: lb://cloud-payment-service
          predicates:
            - Path=/pay/gateway/get/**              # 断言，路径相匹配的进行路由
        - id: pay_routh2 #pay_routh2                #路由的ID(类似mysql主键ID)，没有固定规则但要求唯一，建议配合服务名
          uri: lb://cloud-payment-service
          predicates:
            - Path=/pay/gateway/info/**              # 断言，路径相匹配的进行路由
        - id: pay_routh3
          uri: lb://cloud-payment-service                #匹配后提供服务的路由地址
          predicates:
            - Path=/pay/gateway/filter/**              # 断言，路径相匹配的进行路由
          filters:
            - Status=userStatus  #
```

请求中的查询参数必须带有userStatus才允许访问

#### 测试

http://localhost:9999/pay/gateway/filter

![image-20240403130542774](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031313542.png)



http://localhost:9999/pay/gateway/filter?userStatus=111

![image-20240403130527234](https://gitee.com/dongguo4812_admin/image/raw/master/image/202404031313851.png)

# GateWay整合SpringCloud Alibaba Sentinel实现服务限流

见SpringCloud Alibaba Sentinel章节
