# Gateway简介

Cloud全家桶中有个很重要的组件就是网关，在1.x版本中都是采用的Zuul网关；

但在2.x版本中，zuul的升级一直跳票，SpringCloud最后自己研发了一个网关SpringCloud Gateway替代Zuul，

那就是SpringCloud Gateway一句话：gateway是原zuul1.x版的替代

![image-20240401191114333](F:\note\image\image-20240401191114333.png)

Gateway是在Spring生态系统之上构建的API网关服务，基于Spring6，Spring Boot 3和Project Reactor等技术。它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式，并为它们提供跨领域的关注点，例如：安全性、监控/度量和恢复能力。

https://spring.io/projects/spring-cloud-gateway

## 微服务架构中的网关

![image-20240401191250440](F:\note\image\image-20240401191250440.png)

## 作用

反向代理

鉴权

流量控制

熔断

日志监控



Spring Cloud Gateway组件的核心是一系列的过滤器，通过这些过滤器可以将客户端发送的请求转发(路由)到对应的微服务。 Spring Cloud Gateway是加在整个微服务最前沿的防火墙和代理器，隐藏微服务结点IP端口信息，从而加强安全保护。Spring Cloud Gateway本身也是一个微服务，需要注册进服务注册中心。

![image-20240401191704130](F:\note\image\image-20240401191704130.png)

# Gateway三大核心

![image-20240401192400884](F:\note\image\image-20240401192400884.png)

## Route(路由)

路由是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由



## Predicate(断言)

参考的是Java8的java.util.function.Predicate

开发人员可以匹配HTTP请求中的所有内容(例如请求头或请求参数)，如果请求与断言相匹配则进行路由

## Filter(过滤)

指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。





![image-20240401192808176](F:\note\image\image-20240401192808176.png)

Route：web前端请求，通过一些匹配条件，定位到真正的服务节点。并在这个转发过程的前后，进行一些精细化控制。

predicate就是我们的匹配条件；

filter，就可以理解为一个无所不能的拦截器。有了这两个元素，再加上目标uri，就可以实现一个具体的路由了

# Gateway工作流程

客户端向 Spring Cloud Gateway 发出请求。然后在 Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到 Gateway Web Handler。Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。

过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前（“pre”）或之后（“post”）执行业务逻辑。

Filter在“pre”类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等，

在“post”类型的过滤器中可以做响应内容、响应头的修改，日志的输出，流量监控等有着非常重要的作用。

![image-20240401193043340](F:\note\image\image-20240401193043340.png)

路由转发+执行过滤器链

# 搭建网关服务

Getaway网关也是作为一个服务注册到注册中心。

## 创建网关模块

cloud-gateway9999 

## pom

```xml
        <!--gateway-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-gateway</artifactId>
        </dependency>
        <!--服务注册发现consul discovery,网关也要注册进服务注册中心统一管控-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-consul-discovery</artifactId>
        </dependency>
        <!-- 指标监控健康检查的actuator,网关是响应式编程删除掉spring-boot-starter-web dependency-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
```

## yml

```yaml
server:
  port: 9999

spring:
  application:
    name: cloud-gateway #以微服务注册进consul或nacos服务列表内
  cloud:
    consul: #配置consul地址
      host: localhost
      port: 8500
      discovery:
        prefer-ip-address: true
        service-name: ${spring.application.name}
```

## 主启动

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@SpringBootApplication
@EnableDiscoveryClient //服务注册和发现
public class Gateway9999Application {
    public static void main(String[] args) {
        SpringApplication.run(Gateway9999Application.class, args);
    }
}
```

## 测试

启动Getaway服务，查看是否成功注册到consul

![image-20240401201059035](F:\note\image\image-20240401201059035.png)

# Getaway网关实现路由映射

## cloud-provider-payment8001

新建PayGateWayController

```java
import cn.hutool.core.date.DateUtil;
import com.dongguo.cloud.entity.PO.Pay;
import com.dongguo.cloud.resp.Result;
import com.dongguo.cloud.service.PayService;
import jakarta.annotation.Resource;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class PayGateWayController {
    @Resource
    private PayService payService;

    @GetMapping(value = "/pay/gateway/get/{id}")
    public Result<Pay> getPayById(@PathVariable("id") Integer id) {
        Pay pay = payService.getById(id);
        return Result.success(pay);
    }

    @GetMapping(value = "/pay/gateway/info")
    public Result<String> getGatewayInfo() {
        return Result.success("gateway：" + DateUtil.date());
    }
}
```

## cloud-gateway9999 

我们目前不想暴露8001端口的这两个方法，那么网关如何做路由映射呢？

yml路由配置

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: pay_routh1 #pay_routh1                #路由的ID(类似mysql主键ID)，没有固定规则但要求唯一，建议配合服务名
          uri: http://localhost:8001                #匹配后提供服务的路由地址
          predicates:
            - Path=/pay/gateway/get/**              # 断言，路径相匹配的进行路由
        - id: pay_routh2 #pay_routh2                #路由的ID(类似mysql主键ID)，没有固定规则但要求唯一，建议配合服务名
          uri: http://localhost:8001                #匹配后提供服务的路由地址
          predicates:
            - Path=/pay/gateway/info/**              # 断言，路径相匹配的进行路由
```

## 测试

启动Getaway9999、payment8001

直接访问8001服务：

http://localhost:8001/pay/gateway/get/1

![image-20240401215035633](F:\note\image\image-20240401215035633.png)

http://localhost:8001/pay/gateway/info

![image-20240401215052556](F:\note\image\image-20240401215052556.png)

通过Getaway网关访问8001服务

http://localhost:9999/pay/gateway/get/1

![image-20240401215136054](F:\note\image\image-20240401215136054.png)

http://localhost:9999/pay/gateway/info

![image-20240401215152373](F:\note\image\image-20240401215152373.png)

添加网关后

![image-20240402094834964](F:\note\image\image-20240402094834964.png)

API网关作为服务的前端，接收来自客户端的请求，并根据定义的路由规则将请求转发到相应的后端服务。这样，客户端就不需要直接访问后端服务的端口（如8001），而是可以通过网关的端口（如9999）来访问                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  服务。

![image-20240401215403771](F:\note\image\image-20240401215403771.png)





## 配置了Getaway路由映射，是否会通过网关进行Feign服务调用

之前80订单微服务从Consul注册中心通过微服务名称找到8001支付微服务进行调用，

对8001服务加上了网关，如果我们此时启动80订单，是否会访问网关后才能访问8001？

![image-20240402094225653](F:\note\image\image-20240402094225653.png)

### cloud-api-common

PayFeignApi

```java
/**
 * GateWay进行网关测试案例01
 * @param id
 * @return
 */
@GetMapping(value = "/pay/gateway/get/{id}")
Result getPayById(@PathVariable("id") Integer id);

/**
 * GateWay进行网关测试案例02
 * @return
 */
@GetMapping(value = "/pay/gateway/info")
Result getGatewayInfo();
```

### cloud-consumer-feign-order80

新建OrderGateWayController

```java
port com.dongguo.cloud.feign.PayFeignApi;
import com.dongguo.cloud.resp.Result;
import jakarta.annotation.Resource;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class OrderGateWayController {
    @Resource
    private PayFeignApi payFeignApi;

    @GetMapping(value = "/feign/pay/gateway/get/{id}")
    public Result getPayById(@PathVariable("id") Integer id) {
        return payFeignApi.getPayById(id);
    }

    @GetMapping(value = "/feign/pay/gateway/info")
    public Result getGatewayInfo() {
        return payFeignApi.getGatewayInfo();
    }
}
```

### 测试

http://localhost/feign/pay/gateway/get/1

![image-20240402095842744](F:\note\image\image-20240402095842744.png)

http://localhost/feign/pay/gateway/info

![image-20240402095904697](F:\note\image\image-20240402095904697.png)

80服务依然能够访问到8001服务

我们能够通过日志看到，80服务依然能够访问到8001服务，并且不是通过网关访问

![image-20240402100117804](F:\note\image\image-20240402100117804.png)

这是因为80通过feign调用8001是微服务之间的内部调用

![image-20240402101501137](F:\note\image\image-20240402101501137.png)

在微服务架构中，Feign调用通常是微服务之间直接进行的调用，不会通过API网关的端口来访问后端服务。API网关的主要作用是作为外部请求的统一入口点，负责路由、安全、监控和限流等功能。它通常用于处理来自客户端（如Web浏览器、移动应用等）的请求，并将这些请求路由到相应的微服务。但是，在微服务之间的内部调用中，通常不会通过API网关，因为这样会增加调用的复杂性和延迟。





如果接口是对外提供调用服务，比如现在8001是第三方接口，第三方肯定要求我们访问Getaway服务，而不是直接访问8001服务。

那么就应该将@FeignClient指定为对应的Getaway服务名，先访问Getaway网关，由网关路由映射到真实的服务接口。

![image-20240402101614349](F:\note\image\image-20240402101614349.png)

重新启动成功访问http://localhost/feign/pay/gateway/get/1

![image-20240402102839721](F:\note\image\image-20240402102839721.png)

查看日志

![image-20240402103120493](F:\note\image\image-20240402103120493.png)

如果此时停掉Getaway服务，就无法通过Getaway访问到真实的服务接口。

![image-20240402103311206](F:\note\image\image-20240402103311206.png)

报错：

```shell
Caused by: feign.FeignException$ServiceUnavailable: [503] during [GET] to [http://cloud-gateway/pay/gateway/get/1] [PayFeignApi#getPayById(Integer)]: [Load balancer does not contain an instance for the service cloud-gateway]
	at feign.FeignException.serverErrorStatus(FeignException.java:265) ~[feign-core-13.1.jar:na]
	at feign.FeignException.errorStatus(FeignException.java:206) ~[feign-core-13.1.jar:na]
	at feign.FeignException.errorStatus(FeignException.java:194) ~[feign-core-13.1.jar:na]
	at feign.codec.ErrorDecoder$Default.decode(ErrorDecoder.java:103) ~[feign-core-13.1.jar:na]
	at feign.InvocationContext.decodeError(InvocationContext.java:126) ~[feign-core-13.1.jar:na]
	at feign.InvocationContext.proceed(InvocationContext.java:72) ~[feign-core-13.1.jar:na]
	at feign.ResponseHandler.handleResponse(ResponseHandler.java:63) ~[feign-core-13.1.jar:na]
	at feign.SynchronousMethodHandler.executeAndDecode(SynchronousMethodHandler.java:114) ~[feign-core-13.1.jar:na]
	at feign.SynchronousMethodHandler.invoke(SynchronousMethodHandler.java:70) ~[feign-core-13.1.jar:na]
	at org.springframework.cloud.openfeign.FeignCircuitBreakerInvocationHandler.lambda$asSupplier$1(FeignCircuitBreakerInvocationHandler.java:140) ~[spring-cloud-openfeign-core-4.1.0.jar:4.1.0]
	at io.micrometer.observation.Observation.observe(Observation.java:565) ~[micrometer-observation-1.12.0.jar:1.12.0]
	at org.springframework.cloud.client.circuitbreaker.observation.ObservedSupplier.get(ObservedSupplier.java:48) ~[spring-cloud-commons-4.1.0.jar:4.1.0]
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) ~[na:na]
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136) ~[na:na]
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635) ~[na:na]
	... 1 common frames omitted
```

